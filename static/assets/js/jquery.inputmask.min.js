/*!
 * jquery.inputmask.bundle.js
 * http://github.com/RobinHerbots/jquery.inputmask
 * Copyright (c) 2010 - 2016 Robin Herbots
 * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 * Version: 3.2.7
 */
! function(ve) {
    function he(e, t) {
        return this instanceof he ? (ve.isPlainObject(e) ? t = e : (t = t || {}).alias = e, this.el = void 0, this.opts = ve.extend(!0, {}, this.defaults, t), this.noMasksCache = t && void 0 !== t.definitions, this.userOptions = t || {}, this.events = {}, void u(this.opts.alias, t, this.opts)) : new he(e, t)
    }

    function u(e, t, i) {
        var a = i.aliases[e];
        return a ? (a.alias && u(a.alias, void 0, i), ve.extend(!0, i, a), ve.extend(!0, i, t), !0) : (null === i.mask && (i.mask = e), !1)
    }

    function r(w, n) {
        function e(e, t) {
            if (null !== e && "" !== e) {
                if (1 === e.length && !1 === w.greedy && 0 !== w.repeat && (w.placeholder = ""), 0 < w.repeat || "*" === w.repeat || "+" === w.repeat) {
                    var i = "*" === w.repeat ? 0 : "+" === w.repeat ? 1 : w.repeat;
                    e = w.groupmarker.start + e + w.groupmarker.end + w.quantifiermarker.start + i + "," + w.repeat + w.quantifiermarker.end
                }
                var a;
                return void 0 === he.prototype.masksCache[e] || !0 === n ? (a = {
                    mask: e,
                    maskToken: function(e) {
                        function t(e, t, i, a) {
                            this.matches = [], this.isGroup = e || !1, this.isOptional = t || !1, this.isQuantifier = i || !1, this.isAlternator = a || !1, this.quantifier = {
                                min: 1,
                                max: 1
                            }
                        }

                        function n(e, t, i) {
                            var a = w.definitions[t];
                            i = void 0 !== i ? i : e.matches.length;
                            var n = e.matches[i - 1];
                            if (a && !m) {
                                a.placeholder = ve.isFunction(a.placeholder) ? a.placeholder(w) : a.placeholder;
                                for (var r = a.prevalidator, o = r ? r.length : 0, s = 1; s < a.cardinality; s++) {
                                    var l = s <= o ? r[s - 1] : [],
                                        u = l.validator,
                                        c = l.cardinality;
                                    e.matches.splice(i++, 0, {
                                        fn: u ? "string" == typeof u ? new RegExp(u) : new function() {
                                            this.test = u
                                        } : new RegExp("."),
                                        cardinality: c || 1,
                                        optionality: e.isOptional,
                                        newBlockMarker: void 0 === n || n.def !== (a.definitionSymbol || t),
                                        casing: a.casing,
                                        def: a.definitionSymbol || t,
                                        placeholder: a.placeholder,
                                        mask: t
                                    }), n = e.matches[i - 1]
                                }
                                e.matches.splice(i++, 0, {
                                    fn: a.validator ? "string" == typeof a.validator ? new RegExp(a.validator) : new function() {
                                        this.test = a.validator
                                    } : new RegExp("."),
                                    cardinality: a.cardinality,
                                    optionality: e.isOptional,
                                    newBlockMarker: void 0 === n || n.def !== (a.definitionSymbol || t),
                                    casing: a.casing,
                                    def: a.definitionSymbol || t,
                                    placeholder: a.placeholder,
                                    mask: t
                                })
                            } else e.matches.splice(i++, 0, {
                                fn: null,
                                cardinality: 0,
                                optionality: e.isOptional,
                                newBlockMarker: void 0 === n || n.def !== t,
                                casing: null,
                                def: w.staticDefinitionSymbol || t,
                                placeholder: void 0 !== w.staticDefinitionSymbol ? t : void 0,
                                mask: t
                            }), m = !1
                        }

                        function r(e, t) {
                            e.isGroup && (e.isGroup = !1, n(e, w.groupmarker.start, 0), !0 !== t && n(e, w.groupmarker.end))
                        }

                        function i(e, t, i, a) {
                            0 < t.matches.length && (void 0 === a || a) && r(t.matches[t.matches.length - 1]), n(t, e)
                        }

                        function a() {
                            if (0 < h.length) {
                                if (u = h[h.length - 1], i(s, u, 0, !u.isAlternator), u.isAlternator) {
                                    c = h.pop();
                                    for (var e = 0; e < c.matches.length; e++) c.matches[e].isGroup = !1;
                                    0 < h.length ? (u = h[h.length - 1]).matches.push(c) : v.matches.push(c)
                                }
                            } else i(s, v)
                        }
                        for (var o, s, l, u, c, f, d, p = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g, m = !1, v = new t, h = [], g = []; o = p.exec(e);)
                            if (s = o[0], m) a();
                            else switch (s.charAt(0)) {
                                case w.escapeChar:
                                    m = !0;
                                    break;
                                case w.optionalmarker.end:
                                case w.groupmarker.end:
                                    if (void 0 !== (l = h.pop()))
                                        if (0 < h.length) {
                                            if ((u = h[h.length - 1]).matches.push(l), u.isAlternator) {
                                                c = h.pop();
                                                for (var y = 0; y < c.matches.length; y++) c.matches[y].isGroup = !1;
                                                0 < h.length ? (u = h[h.length - 1]).matches.push(c) : v.matches.push(c)
                                            }
                                        } else v.matches.push(l);
                                    else a();
                                    break;
                                case w.optionalmarker.start:
                                    h.push(new t(!1, !0));
                                    break;
                                case w.groupmarker.start:
                                    h.push(new t(!0));
                                    break;
                                case w.quantifiermarker.start:
                                    var k = new t(!1, !1, !0),
                                        x = (s = s.replace(/[{}]/g, "")).split(","),
                                        b = isNaN(x[0]) ? x[0] : parseInt(x[0]),
                                        P = 1 === x.length ? b : isNaN(x[1]) ? x[1] : parseInt(x[1]);
                                    if (("*" === P || "+" === P) && (b = "*" === P ? 0 : 1), k.quantifier = {
                                            min: b,
                                            max: P
                                        }, 0 < h.length) {
                                        var S = h[h.length - 1].matches;
                                        (o = S.pop()).isGroup || ((d = new t(!0)).matches.push(o), o = d), S.push(o), S.push(k)
                                    } else(o = v.matches.pop()).isGroup || ((d = new t(!0)).matches.push(o), o = d), v.matches.push(o), v.matches.push(k);
                                    break;
                                case w.alternatormarker:
                                    (f = 0 < h.length ? (u = h[h.length - 1]).matches.pop() : v.matches.pop()).isAlternator ? h.push(f) : ((c = new t(!1, !1, !1, !0)).matches.push(f), h.push(c));
                                    break;
                                default:
                                    a()
                            }
                        for (; 0 < h.length;) r(l = h.pop(), !0), v.matches.push(l);
                        return 0 < v.matches.length && (r(f = v.matches[v.matches.length - 1]), g.push(v)), w.numericInput && function e(t) {
                            for (var i in t.matches = t.matches.reverse(), t.matches) {
                                var a = parseInt(i);
                                if (t.matches[i].isQuantifier && t.matches[a + 1] && t.matches[a + 1].isGroup) {
                                    var n = t.matches[i];
                                    t.matches.splice(i, 1), t.matches.splice(a + 1, 0, n)
                                }
                                void 0 !== t.matches[i].matches ? t.matches[i] = e(t.matches[i]) : t.matches[i] = ((r = t.matches[i]) === w.optionalmarker.start ? r = w.optionalmarker.end : r === w.optionalmarker.end ? r = w.optionalmarker.start : r === w.groupmarker.start ? r = w.groupmarker.end : r === w.groupmarker.end && (r = w.groupmarker.start), r)
                            }
                            var r;
                            return t
                        }(g[0]), g
                    }(e),
                    validPositions: {},
                    _buffer: void 0,
                    buffer: void 0,
                    tests: {},
                    metadata: t
                }, !0 !== n && (he.prototype.masksCache[w.numericInput ? e.split("").reverse().join("") : e] = a, a = ve.extend(!0, {}, he.prototype.masksCache[w.numericInput ? e.split("").reverse().join("") : e]))) : a = ve.extend(!0, {}, he.prototype.masksCache[w.numericInput ? e.split("").reverse().join("") : e]), a
            }
        }

        function i(e) {
            return e.toString()
        }
        var t;
        if (ve.isFunction(w.mask) && (w.mask = w.mask(w)), ve.isArray(w.mask)) {
            if (1 < w.mask.length) {
                w.keepStatic = null === w.keepStatic || w.keepStatic;
                var a = "(";
                return ve.each(w.numericInput ? w.mask.reverse() : w.mask, function(e, t) {
                    1 < a.length && (a += ")|("), a += i(void 0 === t.mask || ve.isFunction(t.mask) ? t : t.mask)
                }), e(a += ")", w.mask)
            }
            w.mask = w.mask.pop()
        }
        return w.mask && (t = void 0 === w.mask.mask || ve.isFunction(w.mask.mask) ? e(i(w.mask), w.mask) : e(i(w.mask.mask), w.mask)), t
    }

    function ge(e, t, C) {
        function i(e, t, i) {
            t = t || 0;
            var a, n, r, o = [],
                s = 0,
                l = R();
            do {
                if (!0 === e && T().validPositions[s]) {
                    var u = T().validPositions[s];
                    n = u.match, a = u.locator.slice(), o.push(!0 === i ? u.input : O(s, n))
                } else n = (r = j(s, a, s - 1)).match, a = r.locator.slice(), (!1 === C.jitMasking || s < l || isFinite(C.jitMasking) && C.jitMasking > s) && o.push(O(s, n));
                s++
            } while ((void 0 === X || s - 1 < X) && null !== n.fn || null === n.fn && "" !== n.def || s <= t);
            return "" === o[o.length - 1] && o.pop(), o
        }

        function T() {
            return t
        }

        function E(e) {
            var t = T();
            !(t.buffer = void 0) !== e && (t.tests = {}, t._buffer = void 0, t.validPositions = {}, t.p = 0)
        }

        function R(e, t) {
            var i = -1,
                a = -1,
                n = T().validPositions;
            for (var r in void 0 === e && (e = -1), n) {
                var o = parseInt(r);
                n[o] && (t || null !== n[o].match.fn) && (o <= e && (i = o), e <= o && (a = o))
            }
            return -1 !== i && 1 < e - i || a < e ? i : a
        }

        function k(e, t, i) {
            if (C.insertMode && void 0 !== T().validPositions[e] && void 0 === i) {
                var a, n = ve.extend(!0, {}, T().validPositions),
                    r = R();
                for (a = e; a <= r; a++) delete T().validPositions[a];
                T().validPositions[e] = t;
                var o, s = !0,
                    l = T().validPositions;
                for (a = o = e; a <= r; a++) {
                    var u = n[a];
                    if (void 0 !== u)
                        for (var c = o, f = -1; c < w() && (null == u.match.fn && l[a] && (!0 === l[a].match.optionalQuantifier || !0 === l[a].match.optionality) || null != u.match.fn);) {
                            if (null === u.match.fn || !C.keepStatic && l[a] && (void 0 !== l[a + 1] && 1 < x(a + 1, l[a].locator.slice(), a).length || void 0 !== l[a].alternation) ? c++ : c = A(o), p(c, u.match.def)) {
                                var d = M(c, u.input, !0, !0);
                                s = !1 !== d, o = d.caret || d.insert ? R() : c;
                                break
                            }
                            if (s = null == u.match.fn, f === c) break;
                            f = c
                        }
                    if (!s) break
                }
                if (!s) return T().validPositions = ve.extend(!0, {}, n), E(!0), !1
            } else T().validPositions[e] = t;
            return E(!0), !0
        }

        function g(e, t, i, a) {
            var n, r = e;
            for (T().p = e, n = r; n < t; n++) void 0 !== T().validPositions[n] && (!0 === i || !1 !== C.canClearPosition(T(), n, R(), a, C)) && delete T().validPositions[n];
            for (n = r + 1; n <= R();) {
                for (; void 0 !== T().validPositions[r];) r++;
                var o = T().validPositions[r];
                if (n < r && (n = r + 1), void 0 === T().validPositions[n] && S(n) || void 0 !== o) n++;
                else {
                    var s = j(n);
                    p(r, s.match.def) ? !1 !== M(r, s.input || O(n), !0) && (delete T().validPositions[n], n++) : S(n) || (n++, r--), r++
                }
            }
            var l = R(),
                u = w();
            for (!0 !== a && !0 !== i && void 0 !== T().validPositions[l] && T().validPositions[l].input === C.radixPoint && delete T().validPositions[l], n = l + 1; n <= u; n++) T().validPositions[n] && delete T().validPositions[n];
            E(!0)
        }

        function j(e, t, i) {
            var a = T().validPositions[e];
            if (void 0 === a)
                for (var n = x(e, t, i), r = R(), o = T().validPositions[r] || x(0)[0], s = void 0 !== o.alternation ? o.locator[o.alternation].toString().split(",") : [], l = 0; l < n.length && !((a = n[l]).match && (C.greedy && !0 !== a.match.optionalQuantifier || (!1 === a.match.optionality || !1 === a.match.newBlockMarker) && !0 !== a.match.optionalQuantifier) && (void 0 === o.alternation || o.alternation !== a.alternation || void 0 !== a.locator[o.alternation] && y(a.locator[o.alternation].toString().split(","), s))); l++);
            return a
        }

        function o(e) {
            return T().validPositions[e] ? T().validPositions[e].match : x(e)[0].match
        }

        function p(e, t) {
            for (var i = !1, a = x(e), n = 0; n < a.length; n++)
                if (a[n].match && a[n].match.def === t) {
                    i = !0;
                    break
                }
            return i
        }

        function N(e, a) {
            var n, r;
            return (T().tests[e] || T().validPositions[e]) && ve.each(T().tests[e] || [T().validPositions[e]], function(e, t) {
                var i = t.alternation ? t.locator[t.alternation].toString().indexOf(a) : -1;
                (void 0 === r || i < r) && -1 !== i && (n = t, r = i)
            }), n
        }

        function x(j, e, t) {
            function M(C, E, e, t) {
                function R(e, i, t) {
                    function r(i, a) {
                        var n = 0 === ve.inArray(i, a.matches);
                        return n || ve.each(a.matches, function(e, t) {
                            return (!0 !== t.isQuantifier || !(n = r(i, a.matches[e - 1]))) && void 0
                        }), n
                    }
                    if (1e4 < F) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + T().mask;
                    if (F === j && void 0 === e.matches) return O.push({
                        match: e,
                        locator: i.reverse(),
                        cd: D
                    }), !0;
                    if (void 0 !== e.matches) {
                        if (e.isGroup && t !== e) {
                            if (e = R(C.matches[ve.inArray(e, C.matches) + 1], i)) return !0
                        } else if (e.isOptional) {
                            var a = e;
                            if (e = M(e, E, i, t)) {
                                if (!r(_ = O[O.length - 1].match, a)) return !0;
                                I = !0, F = j
                            }
                        } else if (e.isAlternator) {
                            var n, o = e,
                                s = [],
                                l = O.slice(),
                                u = i.length,
                                c = 0 < E.length ? E.shift() : -1;
                            if (-1 === c || "string" == typeof c) {
                                var f, d = F,
                                    p = E.slice(),
                                    m = [];
                                if ("string" == typeof c) m = c.split(",");
                                else
                                    for (f = 0; f < o.matches.length; f++) m.push(f);
                                for (var v = 0; v < m.length; v++) {
                                    if (f = parseInt(m[v]), O = [], A = void 0, A = N(F, f), E = A ? A.locator.slice(A.alternation + 1) : [], !0 !== (e = R(o.matches[f] || C.matches[f], [f].concat(i), t) || e) && void 0 !== e && m[m.length - 1] < o.matches.length) {
                                        var h = ve.inArray(e, C.matches) + 1;
                                        C.matches.length > h && ((e = R(C.matches[h], [h].concat(i.slice(1, i.length)), t)) && (m.push(h.toString()), ve.each(O, function(e, t) {
                                            t.alternation = i.length - 1
                                        })))
                                    }
                                    n = O.slice(), F = d, O = [];
                                    for (var g = 0; g < p.length; g++) E[g] = p[g];
                                    for (var y = 0; y < n.length; y++) {
                                        var k = n[y];
                                        k.alternation = k.alternation || u;
                                        for (var x = 0; x < s.length; x++) {
                                            var b = s[x];
                                            if (k.match.def === b.match.def && ("string" != typeof c || -1 !== ve.inArray(k.locator[k.alternation].toString(), m))) {
                                                k.match.mask === b.match.mask && (n.splice(y, 1), y--), -1 === b.locator[k.alternation].toString().indexOf(k.locator[k.alternation]) && (b.locator[k.alternation] = b.locator[k.alternation] + "," + k.locator[k.alternation], b.alternation = k.alternation);
                                                break
                                            }
                                        }
                                    }
                                    s = s.concat(n)
                                }
                                "string" == typeof c && (s = ve.map(s, function(e, t) {
                                    if (isFinite(t)) {
                                        var i = e.alternation,
                                            a = e.locator[i].toString().split(",");
                                        e.locator[i] = void 0, e.alternation = void 0;
                                        for (var n = 0; n < a.length; n++) - 1 !== ve.inArray(a[n], m) && (void 0 !== e.locator[i] ? (e.locator[i] += ",", e.locator[i] += a[n]) : e.locator[i] = parseInt(a[n]), e.alternation = i);
                                        if (void 0 !== e.locator[i]) return e
                                    }
                                })), O = l.concat(s), F = j, I = 0 < O.length
                            } else e = R(o.matches[c] || C.matches[c], [c].concat(i), t);
                            if (e) return !0
                        } else if (e.isQuantifier && t !== C.matches[ve.inArray(e, C.matches) - 1])
                            for (var P = e, S = 0 < E.length ? E.shift() : 0; S < (isNaN(P.quantifier.max) ? S + 1 : P.quantifier.max) && F <= j; S++) {
                                var w = C.matches[ve.inArray(P, C.matches) - 1];
                                if (e = R(w, [S].concat(i), w)) {
                                    if ((_ = O[O.length - 1].match).optionalQuantifier = S > P.quantifier.min - 1, r(_, w)) {
                                        if (S > P.quantifier.min - 1) {
                                            I = !0, F = j;
                                            break
                                        }
                                        return !0
                                    }
                                    return !0
                                }
                            } else if (e = M(e, E, i, t)) return !0
                    } else F++;
                    var A
                }
                for (var i = 0 < E.length ? E.shift() : 0; i < C.matches.length; i++)
                    if (!0 !== C.matches[i].isQuantifier) {
                        var a = R(C.matches[i], [i].concat(e), t);
                        if (a && F === j) return a;
                        if (j < F) break
                    }
            }
            var _, i, a = T().maskToken,
                F = e ? t : 0,
                n = e || [0],
                O = [],
                I = !1,
                D = e ? e.join("") : "";
            if (-1 < j) {
                if (void 0 === e) {
                    for (var r, o = j - 1; void 0 === (r = T().validPositions[o] || T().tests[o]) && -1 < o;) o--;
                    void 0 !== r && -1 < o && (n = ((i = r)[0] || i).locator.slice(), D = n.join(""), r = r[0] || r, F = o)
                }
                if (T().tests[j] && T().tests[j][0].cd === D) return T().tests[j];
                for (var s = n.shift(); s < a.length; s++) {
                    if (M(a[s], n, [s]) && F === j || j < F) break
                }
            }
            return (0 === O.length || I) && O.push({
                match: {
                    fn: null,
                    cardinality: 0,
                    optionality: !0,
                    casing: null,
                    def: ""
                },
                locator: []
            }), T().tests[j] = ve.extend(!0, [], O), T().tests[j]
        }

        function f() {
            return void 0 === T()._buffer && (T()._buffer = i(!1, 1)), T()._buffer
        }

        function b(e) {
            if (void 0 === T().buffer || !0 === e) {
                if (!0 === e)
                    for (var t in T().tests) void 0 === T().validPositions[t] && delete T().tests[t];
                T().buffer = i(!0, R(), !0)
            }
            return T().buffer
        }

        function P(e, t, i) {
            var a;
            if (i = i, !0 === e) E(), e = 0, t = i.length;
            else
                for (a = e; a < t; a++) delete T().validPositions[a], delete T().tests[a];
            for (a = e; a < t; a++) E(!0), i[a] !== C.skipOptionalPartCharacter && M(a, i[a], !0, !0)
        }

        function y(e, t) {
            for (var i = C.greedy ? t : t.slice(0, 1), a = !1, n = 0; n < e.length; n++)
                if (-1 !== ve.inArray(e[n], i)) {
                    a = !0;
                    break
                }
            return a
        }

        function M(e, t, i, a) {
            function n(f, d, p, m) {
                var v = !1;
                return ve.each(x(f), function(e, t) {
                    for (var i = t.match, a = d ? 1 : 0, n = "", r = i.cardinality; a < r; r--) n += (o = f - (r - 1), void 0 === T().validPositions[o] ? O(o) : T().validPositions[o].input);
                    var o;
                    if (d && (n += d), b(!0), !1 !== (v = null != i.fn ? i.fn.test(n, T(), f, p, C) : (d === i.def || d === C.skipOptionalPartCharacter) && "" !== i.def && {
                            c: i.placeholder || i.def,
                            pos: f
                        })) {
                        var s = void 0 !== v.c ? v.c : d;
                        s = s === C.skipOptionalPartCharacter && null === i.fn ? i.placeholder || i.def : s;
                        var l = f,
                            u = b();
                        if (void 0 !== v.remove && (ve.isArray(v.remove) || (v.remove = [v.remove]), ve.each(v.remove.sort(function(e, t) {
                                return t - e
                            }), function(e, t) {
                                g(t, t + 1, !0)
                            })), void 0 !== v.insert && (ve.isArray(v.insert) || (v.insert = [v.insert]), ve.each(v.insert.sort(function(e, t) {
                                return e - t
                            }), function(e, t) {
                                M(t.pos, t.c, !1, m)
                            })), v.refreshFromBuffer) {
                            var c = v.refreshFromBuffer;
                            if (P((p = !0) === c ? c : c.start, c.end, u), void 0 === v.pos && void 0 === v.c) return v.pos = R(), !1;
                            if ((l = void 0 !== v.pos ? v.pos : f) !== f) return v = ve.extend(v, M(l, s, !0, m)), !1
                        } else if (!0 !== v && void 0 !== v.pos && v.pos !== f && (l = v.pos, P(f, l, b().slice()), l !== f)) return v = ve.extend(v, M(l, s, !0)), !1;
                        return !0 !== v && void 0 === v.pos && void 0 === v.c || (0 < e && E(!0), k(l, ve.extend({}, t, {
                            input: function(e, t) {
                                switch (t.casing) {
                                    case "upper":
                                        e = e.toUpperCase();
                                        break;
                                    case "lower":
                                        e = e.toLowerCase()
                                }
                                return e
                            }(s, i)
                        }), m) || (v = !1)), !1
                    }
                }), v
            }

            function r(e, t) {
                for (var a = T().validPositions[t].locator, n = a.length, i = e; i < t; i++)
                    if (void 0 === T().validPositions[i] && !S(i, !0)) {
                        var r = x(i),
                            o = r[0],
                            s = -1;
                        ve.each(r, function(e, t) {
                            for (var i = 0; i < n && void 0 !== t.locator[i] && y(t.locator[i].toString().split(","), a[i].toString().split(",")); i++) s < i && (s = i, o = t)
                        }), k(i, ve.extend({}, o, {
                            input: o.match.placeholder || o.match.def
                        }), !0)
                    }
            }
            i = !0 === i;
            for (var o = b(), s = e - 1; - 1 < s && !T().validPositions[s]; s--);
            for (s++; s < e; s++) void 0 === T().validPositions[s] && ((!S(s) || o[s] !== O(s)) && 1 < x(s).length || o[s] === C.radixPoint || "0" === o[s] && ve.inArray(C.radixPoint, o) < s) && n(s, o[s], !0, a);
            var l = e,
                u = !1,
                c = ve.extend(!0, {}, T().validPositions);
            if (l < w() && (u = n(l, t, i, a), (!i || !0 === a) && !1 === u)) {
                var f = T().validPositions[l];
                if (!f || null !== f.match.fn || f.match.def !== t && t !== C.skipOptionalPartCharacter) {
                    if ((C.insertMode || void 0 === T().validPositions[A(l)]) && !S(l, !0)) {
                        var d;
                        n(l, d = (d = j(l).match).placeholder || d.def, i, a);
                        for (var p = l + 1, m = A(l); p <= m; p++)
                            if (!1 !== (u = n(p, t, i, a))) {
                                r(l, p), l = p;
                                break
                            }
                    }
                } else u = {
                    caret: A(l)
                }
            }
            if (!1 === u && C.keepStatic && (u = function(e, t, i, a) {
                    for (var n, r, o, s, l, u, c = ve.extend(!0, {}, T().validPositions), f = ve.extend(!0, {}, T().tests), d = R(); 0 <= d && (!(s = T().validPositions[d]) || void 0 === s.alternation || (n = d, r = T().validPositions[n].alternation, j(n).locator[s.alternation] === s.locator[s.alternation])); d--);
                    if (void 0 !== r)
                        for (var p in n = parseInt(n), T().validPositions)
                            if (p = parseInt(p), s = T().validPositions[p], n <= p && void 0 !== s.alternation) {
                                var m;
                                0 === n ? (m = [], ve.each(T().tests[n], function(e, t) {
                                    void 0 !== t.locator[r] && (m = m.concat(t.locator[r].toString().split(",")))
                                })) : m = T().validPositions[n].locator[r].toString().split(",");
                                var v = void 0 !== s.locator[r] ? s.locator[r] : m[0];
                                0 < v.length && (v = v.split(",")[0]);
                                for (var h = 0; h < m.length; h++) {
                                    var g = [],
                                        y = 0,
                                        k = 0;
                                    if (v < m[h]) {
                                        for (var x, b, P = p; 0 <= P; P--)
                                            if (void 0 !== (x = T().validPositions[P])) {
                                                var S = N(P, m[h]);
                                                T().validPositions[P].match.def !== S.match.def && (g.push(T().validPositions[P].input), T().validPositions[P] = S, T().validPositions[P].input = O(P), null === T().validPositions[P].match.fn && k++, x = S), b = x.locator[r], x.locator[r] = parseInt(m[h]);
                                                break
                                            }
                                        if (v !== x.locator[r]) {
                                            for (l = p + 1; l < R(void 0, !0) + 1; l++)(u = T().validPositions[l]) && null != u.match.fn ? g.push(u.input) : l < e && y++, delete T().validPositions[l], delete T().tests[l];
                                            for (E(!0), C.keepStatic = !C.keepStatic, o = !0; 0 < g.length;) {
                                                var w = g.shift();
                                                if (w !== C.skipOptionalPartCharacter && !(o = M(R(void 0, !0) + 1, w, !1, a))) break
                                            }
                                            if (x.alternation = r, x.locator[r] = b, o) {
                                                var A = R(e) + 1;
                                                for (l = p + 1; l < R() + 1; l++)(void 0 === (u = T().validPositions[l]) || null == u.match.fn) && l < e && k++;
                                                o = M(A < (e += k - y) ? A : e, t, i, a)
                                            }
                                            if (C.keepStatic = !C.keepStatic, o) return o;
                                            E(), T().validPositions = ve.extend(!0, {}, c), T().tests = ve.extend(!0, {}, f)
                                        }
                                    }
                                }
                                break
                            }
                    return !1
                }(e, t, i, a)), !0 === u && (u = {
                    pos: l
                }), ve.isFunction(C.postValidation) && !1 !== u && !i && !0 !== a) {
                var v = C.postValidation(b(!0), u, C);
                if (v) {
                    if (v.refreshFromBuffer) {
                        var h = v.refreshFromBuffer;
                        P(!0 === h ? h : h.start, h.end, v.buffer), E(!0), u = v
                    }
                } else E(!0), T().validPositions = ve.extend(!0, {}, c), u = !1
            }
            return u
        }

        function S(e, t) {
            var i;
            return t ? "" == (i = j(e).match).def && (i = o(e)) : i = o(e), null != i.fn ? i.fn : !0 !== t && -1 < e && !C.keepStatic && void 0 === T().validPositions[e] && 2 < x(e).length
        }

        function w() {
            var e; - 1 === (X = void 0 !== Z ? Z.maxLength : void 0) && (X = void 0);
            var t, i = R(),
                a = T().validPositions[i],
                n = void 0 !== a ? a.locator.slice() : void 0;
            for (t = i + 1; void 0 === a || null !== a.match.fn || null === a.match.fn && "" !== a.match.def; t++) n = (a = j(t, n, t - 1)).locator.slice();
            return e = "" !== o(t - 1).def ? t : t - 1, void 0 === X || e < X ? e : X
        }

        function A(e, t) {
            var i = w();
            if (i <= e) return i;
            for (var a = e; ++a < i && (!0 === t && (!0 !== o(a).newBlockMarker || !S(a)) || !0 !== t && !S(a) && (!0 !== C.nojumps || C.nojumpsThreshold > a)););
            return a
        }

        function _(e, t) {
            var i = e;
            if (i <= 0) return 0;
            for (; 0 < --i && (!0 === t && !0 !== o(i).newBlockMarker || !0 !== t && !S(i)););
            return i
        }

        function F(e, t, i, a, n) {
            if (a && ve.isFunction(C.onBeforeWrite)) {
                var r = C.onBeforeWrite(a, t, i, C);
                if (r) {
                    if (r.refreshFromBuffer) {
                        var o = r.refreshFromBuffer;
                        P(!0 === o ? o : o.start, o.end, r.buffer || t), t = b(!0)
                    }
                    void 0 !== i && (i = void 0 !== r.caret ? r.caret : i)
                }
            }
            void 0 !== e && (e.inputmask._valueSet(t.join("")), void 0 === i || void 0 !== a && "blur" === a.type ? function(e, t, i) {
                function a() {
                    r || null !== s.fn && void 0 !== l.input ? r && null !== s.fn && void 0 !== l.input && (r = !1, n += "</span>") : (r = !0, n += "<span class='im-static''>")
                }
                if (void 0 !== ye) {
                    t = t || b(), void 0 === i ? i = I(e) : void 0 === i.begin && (i = {
                        begin: i,
                        end: i
                    });
                    var n = "",
                        r = !1;
                    if ("" != t)
                        for (var o, s, l, u = 0, c = R(); u === i.begin && document.activeElement === e && (n += "<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>"), T().validPositions[u] ? (l = T().validPositions[u], s = l.match, o = l.locator.slice(), a(), n += l.input) : (l = j(u, o, u - 1), s = l.match, o = l.locator.slice(), (!1 === C.jitMasking || u < c || "number" == typeof C.jitMasking && isFinite(C.jitMasking) && C.jitMasking > u) && (a(), n += O(u, s))), u++, (void 0 === X || u < X) && (null !== s.fn || "" !== s.def) || u < c;);
                    ye.innerHTML = n
                }
            }(e, t, i) : Pe && "input" === a.type ? setTimeout(function() {
                I(e, i)
            }, 0) : I(e, i), !0 === n && (ae = !0, ve(e).trigger("input")))
        }

        function O(e, t) {
            if (void 0 !== (t = t || o(e)).placeholder) return t.placeholder;
            if (null !== t.fn) return C.placeholder.charAt(e % C.placeholder.length);
            if (-1 < e && !C.keepStatic && void 0 === T().validPositions[e]) {
                var i, a = x(e),
                    n = 0;
                if (2 < a.length)
                    for (var r = 0; r < a.length; r++)
                        if (!0 !== a[r].match.optionality && !0 !== a[r].match.optionalQuantifier && (null === a[r].match.fn || void 0 === i || !1 !== a[r].match.fn.test(i.match.def, T(), e, !0, C)) && (n++, null === a[r].match.fn && (i = a[r]), 1 < n)) return C.placeholder.charAt(e % C.placeholder.length)
            }
            return t.def
        }

        function u(s, e, l, t) {
            var i = t.slice(),
                u = "",
                c = 0;
            if (E(), T().p = A(-1), !l)
                if (!0 !== C.autoUnmask) {
                    var a = f().slice(0, A(-1)).join(""),
                        n = i.join("").match(new RegExp("^" + he.escapeRegex(a), "g"));
                    n && 0 < n.length && (i.splice(0, n.length * a.length), c = A(c))
                } else c = A(c);
            ve.each(i, function(e, t) {
                if (void 0 !== t) {
                    var i = new ve.Event("keypress");
                    i.which = t.charCodeAt(0), u += t;
                    var a = R(void 0, !0),
                        n = T().validPositions[a],
                        r = j(a + 1, n ? n.locator.slice() : void 0, a);
                    if (! function() {
                            var e = !1,
                                t = f().slice(c, A(c)).join("").indexOf(u);
                            if (-1 !== t && !S(c)) {
                                e = !0;
                                for (var i = f().slice(c, c + t), a = 0; a < i.length; a++)
                                    if (" " !== i[a]) {
                                        e = !1;
                                        break
                                    }
                            }
                            return e
                        }() || l || C.autoUnmask) {
                        var o = l ? e : null == r.match.fn && r.match.optionality && a + 1 < T().p ? a + 1 : T().p;
                        d.call(s, i, !0, !1, l, o), c = o + 1, u = ""
                    } else d.call(s, i, !0, !1, !0, a + 1)
                }
            }), e && F(s, b(), document.activeElement === s ? A(R(0)) : void 0, new ve.Event("checkval"))
        }

        function a(e) {
            if (e && void 0 === e.inputmask) return e.value;
            var t = [],
                i = T().validPositions;
            for (var a in i) i[a].match && null != i[a].match.fn && t.push(i[a].input);
            var n = 0 === t.length ? null : (te ? t.reverse() : t).join("");
            if (null !== n) {
                var r = (te ? b().slice().reverse() : b()).join("");
                ve.isFunction(C.onUnMask) && (n = C.onUnMask(r, n, C) || n)
            }
            return n
        }

        function I(e, t, i, a) {
            function n(e) {
                !0 === a || !te || "number" != typeof e || C.greedy && "" === C.placeholder || (e = b().join("").length - e);
                return e
            }
            var r;
            if ("number" != typeof t) return e.setSelectionRange ? (t = e.selectionStart, i = e.selectionEnd) : window.getSelection ? ((r = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode === e || r.commonAncestorContainer === e) && (t = r.startOffset, i = r.endOffset) : document.selection && document.selection.createRange && (i = (t = 0 - (r = document.selection.createRange()).duplicate().moveStart("character", -1e5)) + r.text.length), {
                begin: n(t),
                end: n(i)
            };
            t = n(t), i = "number" == typeof(i = n(i)) ? i : t;
            var o = parseInt(((e.ownerDocument.defaultView || window).getComputedStyle ? (e.ownerDocument.defaultView || window).getComputedStyle(e, null) : e.currentStyle).fontSize) * i;
            if (e.scrollLeft = o > e.scrollWidth ? o : 0, ke || !1 !== C.insertMode || t !== i || i++, e.setSelectionRange) e.selectionStart = t, e.selectionEnd = i;
            else if (window.getSelection) {
                if (r = document.createRange(), void 0 === e.firstChild || null === e.firstChild) {
                    var s = document.createTextNode("");
                    e.appendChild(s)
                }
                r.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length), r.setEnd(e.firstChild, i < e.inputmask._valueGet().length ? i : e.inputmask._valueGet().length), r.collapse(!0);
                var l = window.getSelection();
                l.removeAllRanges(), l.addRange(r)
            } else e.createTextRange && ((r = e.createTextRange()).collapse(!0), r.moveEnd("character", i), r.moveStart("character", t), r.select())
        }

        function s(e) {
            var t, i, a = b(),
                n = a.length,
                r = R(),
                o = {},
                s = T().validPositions[r],
                l = void 0 !== s ? s.locator.slice() : void 0;
            for (t = r + 1; t < a.length; t++) l = (i = j(t, l, t - 1)).locator.slice(), o[t] = ve.extend(!0, {}, i);
            var u = s && void 0 !== s.alternation ? s.locator[s.alternation] : void 0;
            for (t = n - 1; r < t && (((i = o[t]).match.optionality || i.match.optionalQuantifier || u && (u !== o[t].locator[s.alternation] && null != i.match.fn || null === i.match.fn && i.locator[s.alternation] && y(i.locator[s.alternation].toString().split(","), u.toString().split(",")) && "" !== x(t)[0].def)) && a[t] === O(t, i.match)); t--) n--;
            return e ? {
                l: n,
                def: o[n] ? o[n].match : void 0
            } : n
        }

        function l(e) {
            for (var t = s(), i = e.length - 1; t < i && !S(i); i--);
            return e.splice(t, i + 1 - t), e
        }

        function D(e) {
            if (ve.isFunction(C.isComplete)) return C.isComplete(e, C);
            if ("*" !== C.repeat) {
                var t = !1,
                    i = s(!0),
                    a = _(i.l);
                if (void 0 === i.def || i.def.newBlockMarker || i.def.optionality || i.def.optionalQuantifier) {
                    t = !0;
                    for (var n = 0; n <= a; n++) {
                        var r = j(n).match;
                        if (null !== r.fn && void 0 === T().validPositions[n] && !0 !== r.optionality && !0 !== r.optionalQuantifier || null === r.fn && e[n] !== O(n, r)) {
                            t = !1;
                            break
                        }
                    }
                }
                return t
            }
        }

        function G(r, e, t, i) {
            if ((C.numericInput || te) && (e === he.keyCode.BACKSPACE ? e = he.keyCode.DELETE : e === he.keyCode.DELETE && (e = he.keyCode.BACKSPACE), te)) {
                var a = t.end;
                t.end = t.begin, t.begin = a
            }
            e === he.keyCode.BACKSPACE && (t.end - t.begin < 1 || !1 === C.insertMode) ? (t.begin = _(t.begin), void 0 === T().validPositions[t.begin] || T().validPositions[t.begin].input !== C.groupSeparator && T().validPositions[t.begin].input !== C.radixPoint || t.begin--) : e === he.keyCode.DELETE && t.begin === t.end && (t.end = S(t.end) ? t.end + 1 : A(t.end) + 1, void 0 === T().validPositions[t.begin] || T().validPositions[t.begin].input !== C.groupSeparator && T().validPositions[t.begin].input !== C.radixPoint || t.end++), g(t.begin, t.end, !1, i), !0 !== i && function() {
                if (C.keepStatic) {
                    E(!0);
                    var e, t = [],
                        i = ve.extend(!0, {}, T().validPositions);
                    for (e = R(); 0 <= e; e--) {
                        var a = T().validPositions[e];
                        if (a && (null != a.match.fn && t.push(a.input), delete T().validPositions[e], void 0 !== a.alternation && a.locator[a.alternation] === j(e).locator[a.alternation])) break
                    }
                    if (-1 < e)
                        for (; 0 < t.length;) {
                            T().p = A(R());
                            var n = new ve.Event("keypress");
                            n.which = t.pop().charCodeAt(0), d.call(r, n, !0, !1, !1, T().p)
                        } else T().validPositions = ve.extend(!0, {}, i)
                }
            }();
            var n = R(t.begin);
            n < t.begin ? (-1 === n && E(), T().p = A(n)) : !0 !== i && (T().p = t.begin)
        }

        function c(e) {
            var t = this,
                i = ve(t),
                a = e.keyCode,
                n = I(t);
            if (a === he.keyCode.BACKSPACE || a === he.keyCode.DELETE || be && 127 === a || e.ctrlKey && 88 === a && ! function(e) {
                    var t = document.createElement("input"),
                        i = "on" + e,
                        a = i in t;
                    return a || (t.setAttribute(i, "return;"), a = "function" == typeof t[i]), t = null, a
                }("cut")) e.preventDefault(), 88 === a && (Y = b().join("")), G(t, a, n), F(t, b(), T().p, e, Y !== b().join("")), t.inputmask._valueGet() === f().join("") ? i.trigger("cleared") : !0 === D(b()) && i.trigger("complete"), C.showTooltip && (t.title = C.tooltip || T().mask);
            else if (a === he.keyCode.END || a === he.keyCode.PAGE_DOWN) {
                e.preventDefault();
                var r = A(R());
                C.insertMode || r !== w() || e.shiftKey || r--, I(t, e.shiftKey ? n.begin : r, r, !0)
            } else a === he.keyCode.HOME && !e.shiftKey || a === he.keyCode.PAGE_UP ? (e.preventDefault(), I(t, 0, e.shiftKey ? n.begin : 0, !0)) : (C.undoOnEscape && a === he.keyCode.ESCAPE || 90 === a && e.ctrlKey) && !0 !== e.altKey ? (u(t, !0, !1, Y.split("")), i.trigger("click")) : a !== he.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === C.tabThrough && a === he.keyCode.TAB ? (!0 === e.shiftKey ? (null === o(n.begin).fn && (n.begin = A(n.begin)), n.end = _(n.begin, !0), n.begin = _(n.end, !0)) : (n.begin = A(n.begin, !0), n.end = A(n.begin, !0), n.end < w() && n.end--), n.begin < w() && (e.preventDefault(), I(t, n.begin, n.end))) : !1 !== C.insertMode || e.shiftKey || (a === he.keyCode.RIGHT ? setTimeout(function() {
                var e = I(t);
                I(t, e.begin)
            }, 0) : a === he.keyCode.LEFT && setTimeout(function() {
                var e = I(t);
                I(t, te ? e.begin + 1 : e.begin - 1)
            }, 0)) : (C.insertMode = !C.insertMode, I(t, C.insertMode || n.begin !== w() ? n.begin : n.begin - 1));
            C.onKeyDown.call(this, e, b(), I(t).begin, C), ne = -1 !== ve.inArray(a, C.ignorables)
        }

        function d(e, t, i, a, n) {
            var r = this,
                o = ve(r),
                s = e.which || e.charCode || e.keyCode;
            if (!(!0 === t || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ne)) return s === he.keyCode.ENTER && Y !== b().join("") && (Y = b().join(""), setTimeout(function() {
                o.trigger("change")
            }, 0)), !0;
            if (s) {
                46 === s && !1 === e.shiftKey && "," === C.radixPoint && (s = 44);
                var l, u = t ? {
                        begin: n,
                        end: n
                    } : I(r),
                    c = String.fromCharCode(s),
                    f = function(e, t) {
                        return te ? 1 < e - t || e - t == 1 && C.insertMode : 1 < t - e || t - e == 1 && C.insertMode
                    }(u.begin, u.end);
                f && (T().undoPositions = ve.extend(!0, {}, T().validPositions), G(r, he.keyCode.DELETE, u, !0), u.begin = T().p, C.insertMode || (C.insertMode = !C.insertMode, k(u.begin, a), C.insertMode = !C.insertMode), f = !C.multi), T().writeOutBuffer = !0;
                var d = te && !f ? u.end : u.begin,
                    p = M(d, c, a);
                if (!1 !== p) {
                    if (!0 !== p && (d = void 0 !== p.pos ? p.pos : d, c = void 0 !== p.c ? p.c : c), E(!0), void 0 !== p.caret) l = p.caret;
                    else {
                        var m = T().validPositions;
                        l = !C.keepStatic && (void 0 !== m[d + 1] && 1 < x(d + 1, m[d].locator.slice(), d).length || void 0 !== m[d].alternation) ? d + 1 : A(d)
                    }
                    T().p = l
                }
                if (!1 !== i) {
                    var v = this;
                    if (setTimeout(function() {
                            C.onKeyValidation.call(v, s, p, C)
                        }, 0), T().writeOutBuffer && !1 !== p) {
                        var h = b();
                        F(r, h, C.numericInput && void 0 === p.caret ? _(l) : l, e, !0 !== t), !0 !== t && setTimeout(function() {
                            !0 === D(h) && o.trigger("complete")
                        }, 0)
                    } else f && (T().buffer = void 0, T().validPositions = T().undoPositions)
                } else f && (T().buffer = void 0, T().validPositions = T().undoPositions);
                if (C.showTooltip && (r.title = C.tooltip || T().mask), t && ve.isFunction(C.onBeforeWrite)) {
                    var g = C.onBeforeWrite(e, b(), l, C);
                    if (g && g.refreshFromBuffer) {
                        var y = g.refreshFromBuffer;
                        P(!0 === y ? y : y.start, y.end, g.buffer), E(!0), g.caret && (T().p = g.caret)
                    }
                }
                if (e.preventDefault(), t) return p
            }
        }

        function n(e) {
            var t = this,
                i = e.originalEvent || e,
                a = ve(t),
                n = t.inputmask._valueGet(!0),
                r = I(t),
                o = n.substr(0, r.begin),
                s = n.substr(r.end, n.length);
            o === f().slice(0, r.begin).join("") && (o = ""), s === f().slice(r.end).join("") && (s = ""), window.clipboardData && window.clipboardData.getData ? n = o + window.clipboardData.getData("Text") + s : i.clipboardData && i.clipboardData.getData && (n = o + i.clipboardData.getData("text/plain") + s);
            var l = n;
            if (ve.isFunction(C.onBeforePaste)) {
                if (!1 === (l = C.onBeforePaste(n, C))) return e.preventDefault(), !1;
                l || (l = n)
            }
            return u(t, !1, !1, te ? l.split("").reverse() : l.toString().split("")), F(t, b(), void 0, e, !0), a.trigger("click"), !0 === D(b()) && a.trigger("complete"), !1
        }

        function r(e) {
            var t = this,
                i = t.inputmask._valueGet();
            if (b().join("") !== i) {
                var a = I(t);
                if (i = i.replace(new RegExp("(" + he.escapeRegex(f().join("")) + ")*"), ""), xe) {
                    var n = i.replace(b().join(""), "");
                    if (1 === n.length) {
                        var r = new ve.Event("keypress");
                        return r.which = n.charCodeAt(0), d.call(t, r, !0, !0, !1, T().validPositions[a.begin - 1] ? a.begin : a.begin - 1), !1
                    }
                }
                if (a.begin > i.length && (I(t, i.length), a = I(t)), b().length - i.length != 1 || i.charAt(a.begin) === b()[a.begin] || i.charAt(a.begin + 1) === b()[a.begin] || S(a.begin)) {
                    for (var o = R() + 1, s = b().slice(o).join(""); null === i.match(he.escapeRegex(s) + "$");) s = s.slice(1);
                    u(t, !0, !1, i = (i = i.replace(s, "")).split("")), !0 === D(b()) && ve(t).trigger("complete")
                } else e.keyCode = he.keyCode.BACKSPACE, c.call(t, e);
                e.preventDefault()
            }
        }

        function m(e) {
            var t = e.originalEvent || e;
            Y = b().join(""), "" === $ || t.data.indexOf($)
        }

        function v(e) {
            var t = this,
                i = e.originalEvent || e,
                a = b().join("");
            0 === i.data.indexOf($) && (E(), T().p = A(-1));
            for (var n = i.data, r = 0; r < n.length; r++) {
                var o = new ve.Event("keypress");
                o.which = n.charCodeAt(r), d.call(t, o, !(ne = ie = !1), !1, !1, T().p)
            }
            a !== b().join("") && setTimeout(function() {
                var e = T().p;
                F(t, b(), C.numericInput ? _(e) : e)
            }, 0), $ = i.data
        }

        function h(e) {}

        function B(e) {
            var t = this.inputmask._valueGet();
            u(this, !0, !1, (ve.isFunction(C.onBeforeMask) && C.onBeforeMask(t, C) || t).split("")), Y = b().join(""), (C.clearMaskOnLostFocus || C.clearIncomplete) && this.inputmask._valueGet() === f().join("") && this.inputmask._valueSet("")
        }

        function K(e) {
            var t = this,
                i = t.inputmask._valueGet();
            C.showMaskOnFocus && (!C.showMaskOnHover || C.showMaskOnHover && "" === i) ? t.inputmask._valueGet() !== b().join("") && F(t, b(), A(R())) : !1 === re && I(t, A(R())), !0 === C.positionCaretOnTab && setTimeout(function() {
                I(t, A(R()))
            }, 0), Y = b().join("")
        }

        function L(e) {
            if (re = !1, C.clearMaskOnLostFocus && document.activeElement !== this) {
                var t = b().slice(),
                    i = this.inputmask._valueGet();
                i !== this.getAttribute("placeholder") && "" !== i && (-1 === R() && i === f().join("") ? t = [] : l(t), F(this, t))
            }
        }

        function H(e) {
            var t = this;
            if (document.activeElement === t) {
                var i = I(t);
                if (i.begin === i.end)
                    if (function(e) {
                            if (C.radixFocus && "" !== C.radixPoint) {
                                var t = T().validPositions;
                                if (void 0 === t[e] || t[e].input === O(e)) {
                                    if (e < A(-1)) return !0;
                                    var i = ve.inArray(C.radixPoint, b());
                                    if (-1 !== i) {
                                        for (var a in t)
                                            if (i < a && t[a].input !== O(a)) return !1;
                                        return !0
                                    }
                                }
                            }
                            return !1
                        }(i.begin)) I(t, C.numericInput ? A(ve.inArray(C.radixPoint, b())) : ve.inArray(C.radixPoint, b()));
                    else {
                        var a = i.begin,
                            n = A(R(a));
                        a < n ? I(t, S(a) || S(a - 1) ? a : A(a)) : ((b()[n] !== O(n) || !S(n, !0) && o(n).def === O(n)) && (n = A(n)), I(t, n))
                    }
            }
        }

        function U(e) {
            var t = this;
            setTimeout(function() {
                I(t, 0, A(R()))
            }, 0)
        }

        function Q(e) {
            var t = this,
                i = ve(t),
                a = I(t),
                n = e.originalEvent || e,
                r = window.clipboardData || n.clipboardData,
                o = te ? b().slice(a.end, a.begin) : b().slice(a.begin, a.end);
            r.setData("text", te ? o.reverse().join("") : o.join("")), document.execCommand && document.execCommand("copy"), G(t, he.keyCode.DELETE, a), F(t, b(), T().p, e, Y !== b().join("")), t.inputmask._valueGet() === f().join("") && i.trigger("cleared"), C.showTooltip && (t.title = C.tooltip || T().mask)
        }

        function V(e) {
            var t = ve(this);
            if (this.inputmask) {
                var i = this.inputmask._valueGet(),
                    a = b().slice();
                Y !== a.join("") && setTimeout(function() {
                    t.trigger("change"), Y = a.join("")
                }, 0), "" !== i && (C.clearMaskOnLostFocus && (-1 === R() && i === f().join("") ? a = [] : l(a)), !1 === D(a) && (setTimeout(function() {
                    t.trigger("incomplete")
                }, 0), C.clearIncomplete && (E(), a = C.clearMaskOnLostFocus ? [] : f().slice())), F(this, a, void 0, e))
            }
        }

        function q(e) {
            re = !0, document.activeElement !== this && C.showMaskOnHover && this.inputmask._valueGet() !== b().join("") && F(this, b())
        }

        function z(e) {
            Y !== b().join("") && J.trigger("change"), C.clearMaskOnLostFocus && -1 === R() && Z.inputmask._valueGet && Z.inputmask._valueGet() === f().join("") && Z.inputmask._valueSet(""), C.removeMaskOnSubmit && (Z.inputmask._valueSet(Z.inputmask.unmaskedvalue(), !0), setTimeout(function() {
                F(Z, b())
            }, 0))
        }

        function W(e) {
            setTimeout(function() {
                J.trigger("setvalue")
            }, 0)
        }
        var Y, $, Z, J, X, ee, te = !1,
            ie = !1,
            ae = !1,
            ne = !1,
            re = !0,
            oe = !1,
            se = {
                on: function(e, t, a) {
                    var i = function(e) {
                        if (void 0 === this.inputmask && "FORM" !== this.nodeName) {
                            var t = ve.data(this, "_inputmask_opts");
                            t ? new he(t).mask(this) : se.off(this)
                        } else {
                            if ("setvalue" === e.type || !(this.disabled || this.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === C.tabThrough && e.keyCode === he.keyCode.TAB))) {
                                switch (e.type) {
                                    case "input":
                                        if (!0 === ae || !0 === oe) return ae = oe, e.preventDefault();
                                        break;
                                    case "keydown":
                                        oe = ae = ie = !1;
                                        break;
                                    case "keypress":
                                        if (!0 === ie) return e.preventDefault();
                                        ie = !0;
                                        break;
                                    case "compositionstart":
                                        oe = !0;
                                        break;
                                    case "compositionupdate":
                                        ae = !0;
                                        break;
                                    case "compositionend":
                                        oe = !1;
                                        break;
                                    case "cut":
                                        ae = !0;
                                        break;
                                    case "click":
                                        if (xe) {
                                            var i = this;
                                            return setTimeout(function() {
                                                a.apply(i, arguments)
                                            }, 0), !1
                                        }
                                }
                                return a.apply(this, arguments)
                            }
                            e.preventDefault()
                        }
                    };
                    e.inputmask.events[t] = e.inputmask.events[t] || [], e.inputmask.events[t].push(i), -1 !== ve.inArray(t, ["submit", "reset"]) ? null != e.form && ve(e.form).on(t, i) : ve(e).on(t, i)
                },
                off: function(a, e) {
                    var t;
                    a.inputmask && a.inputmask.events && (e ? (t = [])[e] = a.inputmask.events[e] : t = a.inputmask.events, ve.each(t, function(e, t) {
                        for (; 0 < t.length;) {
                            var i = t.pop(); - 1 !== ve.inArray(e, ["submit", "reset"]) ? null != a.form && ve(a.form).off(e, i) : ve(a).off(e, i)
                        }
                        delete a.inputmask.events[e]
                    }))
                }
            };
        if (void 0 !== e) switch (e.action) {
            case "isComplete":
                return Z = e.el, D(b());
            case "unmaskedvalue":
                return void 0 !== (Z = e.el) && void 0 !== Z.inputmask ? (t = Z.inputmask.maskset, C = Z.inputmask.opts, te = Z.inputmask.isRTL) : (ee = e.value, C.numericInput && (te = !0), ee = (ve.isFunction(C.onBeforeMask) && C.onBeforeMask(ee, C) || ee).split(""), u(void 0, !1, !1, te ? ee.reverse() : ee), ve.isFunction(C.onBeforeWrite) && C.onBeforeWrite(void 0, b(), 0, C)), a(Z);
            case "mask":
                Z = e.el, t = Z.inputmask.maskset, C = Z.inputmask.opts, te = Z.inputmask.isRTL, Y = b().join(""),
                    function(e) {
                        if (J = ve(Z = e), C.showTooltip && (Z.title = C.tooltip || T().mask), ("rtl" === Z.dir || C.rightAlign) && (Z.style.textAlign = "right"), ("rtl" === Z.dir || C.numericInput) && (Z.dir = "ltr", Z.removeAttribute("dir"), Z.inputmask.isRTL = !0, te = !0), se.off(Z), function(t) {
                                function e() {
                                    return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : a.call(this) !== f().join("") ? document.activeElement === this && C.clearMaskOnLostFocus ? (te ? l(b().slice()).reverse() : l(b().slice())).join("") : a.call(this) : "" : a.call(this)
                                }

                                function i(e) {
                                    n.call(this, e), this.inputmask && ve(this).trigger("setvalue")
                                }
                                var a, n, r;
                                t.inputmask.__valueGet || (Object.getOwnPropertyDescriptor && void 0 === t.value ? (a = function() {
                                    return this.textContent
                                }, n = function(e) {
                                    this.textContent = e
                                }, Object.defineProperty(t, "value", {
                                    get: e,
                                    set: i
                                })) : document.__lookupGetter__ && t.__lookupGetter__("value") ? (a = t.__lookupGetter__("value"), n = t.__lookupSetter__("value"), t.__defineGetter__("value", e), t.__defineSetter__("value", i)) : (a = function() {
                                    return t.value
                                }, n = function(e) {
                                    t.value = e
                                }, function(e) {
                                    if (ve.valHooks && (void 0 === ve.valHooks[e] || !0 !== ve.valHooks[e].inputmaskpatch)) {
                                        var a = ve.valHooks[e] && ve.valHooks[e].get ? ve.valHooks[e].get : function(e) {
                                                return e.value
                                            },
                                            n = ve.valHooks[e] && ve.valHooks[e].set ? ve.valHooks[e].set : function(e, t) {
                                                return e.value = t, e
                                            };
                                        ve.valHooks[e] = {
                                            get: function(e) {
                                                if (e.inputmask) {
                                                    if (e.inputmask.opts.autoUnmask) return e.inputmask.unmaskedvalue();
                                                    var t = a(e),
                                                        i = e.inputmask.maskset._buffer;
                                                    return t !== (i = i ? i.join("") : "") ? t : ""
                                                }
                                                return a(e)
                                            },
                                            set: function(e, t) {
                                                var i, a = ve(e);
                                                return i = n(e, t), e.inputmask && a.trigger("setvalue"), i
                                            },
                                            inputmaskpatch: !0
                                        }
                                    }
                                }(t.type), r = t, se.on(r, "mouseenter", function(e) {
                                    var t = ve(this);
                                    this.inputmask._valueGet() !== b().join("") && 0 < R() && t.trigger("setvalue")
                                })), t.inputmask.__valueGet = a, t.inputmask._valueGet = function(e) {
                                    return te && !0 !== e ? a.call(this.el).split("").reverse().join("") : a.call(this.el)
                                }, t.inputmask.__valueSet = n, t.inputmask._valueSet = function(e, t) {
                                    n.call(this.el, null == e ? "" : !0 !== t && te ? e.split("").reverse().join("") : e)
                                })
                            }(Z), function(e, t) {
                                var i = e.getAttribute("type"),
                                    a = "INPUT" === e.tagName && -1 !== ve.inArray(i, t.supportsInputType) || e.isContentEditable || "TEXTAREA" === e.tagName;
                                if (!a) {
                                    var n = document.createElement("input");
                                    n.setAttribute("type", i), a = "text" === n.type, n = null
                                }
                                return a
                            }(Z, C) && (se.on(Z, "submit", z), se.on(Z, "reset", W), se.on(Z, "mouseenter", q), se.on(Z, "blur", V), se.on(Z, "focus", K), se.on(Z, "mouseleave", L), se.on(Z, "click", H), se.on(Z, "dblclick", U), se.on(Z, "paste", n), se.on(Z, "dragdrop", n), se.on(Z, "drop", n), se.on(Z, "cut", Q), se.on(Z, "complete", C.oncomplete), se.on(Z, "incomplete", C.onincomplete), se.on(Z, "cleared", C.oncleared), se.on(Z, "keydown", c), se.on(Z, "keypress", d), se.on(Z, "input", r), ke || (se.on(Z, "compositionstart", m), se.on(Z, "compositionupdate", v), se.on(Z, "compositionend", h))), se.on(Z, "setvalue", B), "" !== Z.inputmask._valueGet() || !1 === C.clearMaskOnLostFocus) {
                            var t = ve.isFunction(C.onBeforeMask) && C.onBeforeMask(Z.inputmask._valueGet(), C) || Z.inputmask._valueGet();
                            u(Z, !0, !1, t.split(""));
                            var i = b().slice();
                            Y = i.join(""), !1 === D(i) && C.clearIncomplete && E(), C.clearMaskOnLostFocus && (i.join("") === f().join("") ? i = [] : l(i)), F(Z, i), document.activeElement === Z && I(Z, A(R()))
                        }
                    }(Z);
                break;
            case "format":
                return C.numericInput && (te = !0), ee = (ve.isFunction(C.onBeforeMask) && C.onBeforeMask(e.value, C) || e.value).split(""), u(void 0, !1, !1, te ? ee.reverse() : ee), ve.isFunction(C.onBeforeWrite) && C.onBeforeWrite(void 0, b(), 0, C), e.metadata ? {
                    value: te ? b().slice().reverse().join("") : b().join(""),
                    metadata: ge({
                        action: "getmetadata"
                    }, t, C)
                } : te ? b().slice().reverse().join("") : b().join("");
            case "isValid":
                C.numericInput && (te = !0), e.value ? (ee = e.value.split(""), u(void 0, !1, !0, te ? ee.reverse() : ee)) : e.value = b().join("");
                for (var le = b(), ue = s(), ce = le.length - 1; ue < ce && !S(ce); ce--);
                return le.splice(ue, ce + 1 - ue), D(le) && e.value === b().join("");
            case "getemptymask":
                return f();
            case "remove":
                var fe;
                Z = e.el, J = ve(Z), t = Z.inputmask.maskset, C = Z.inputmask.opts, Z.inputmask._valueSet(a(Z)), se.off(Z), Object.getOwnPropertyDescriptor && (fe = Object.getOwnPropertyDescriptor(Z, "value")), fe && fe.get ? Z.inputmask.__valueGet && Object.defineProperty(Z, "value", {
                    get: Z.inputmask.__valueGet,
                    set: Z.inputmask.__valueSet
                }) : document.__lookupGetter__ && Z.__lookupGetter__("value") && Z.inputmask.__valueGet && (Z.__defineGetter__("value", Z.inputmask.__valueGet), Z.__defineSetter__("value", Z.inputmask.__valueSet)), Z.inputmask = void 0;
                break;
            case "getmetadata":
                if (ve.isArray(t.metadata)) {
                    for (var de, pe = R(), me = pe; 0 <= me; me--)
                        if (T().validPositions[me] && void 0 !== T().validPositions[me].alternation) {
                            de = T().validPositions[me].alternation;
                            break
                        }
                    return void 0 !== de ? t.metadata[T().validPositions[pe].locator[de]] : t.metadata[0]
                }
                return t.metadata
        }
    }
    he.prototype = {
        defaults: {
            placeholder: "_",
            optionalmarker: {
                start: "[",
                end: "]"
            },
            quantifiermarker: {
                start: "{",
                end: "}"
            },
            groupmarker: {
                start: "(",
                end: ")"
            },
            alternatormarker: "|",
            escapeChar: "\\",
            mask: null,
            oncomplete: ve.noop,
            onincomplete: ve.noop,
            oncleared: ve.noop,
            repeat: 0,
            greedy: !0,
            autoUnmask: !1,
            removeMaskOnSubmit: !1,
            clearMaskOnLostFocus: !0,
            insertMode: !0,
            clearIncomplete: !1,
            aliases: {},
            alias: null,
            onKeyDown: ve.noop,
            onBeforeMask: null,
            onBeforePaste: function(e, t) {
                return ve.isFunction(t.onBeforeMask) ? t.onBeforeMask(e, t) : e
            },
            onBeforeWrite: null,
            onUnMask: null,
            showMaskOnFocus: !0,
            showMaskOnHover: !0,
            onKeyValidation: ve.noop,
            skipOptionalPartCharacter: " ",
            showTooltip: !1,
            tooltip: void 0,
            numericInput: !1,
            rightAlign: !1,
            undoOnEscape: !0,
            radixPoint: "",
            groupSeparator: "",
            radixFocus: !1,
            nojumps: !1,
            nojumpsThreshold: 0,
            keepStatic: null,
            positionCaretOnTab: !1,
            tabThrough: !1,
            supportsInputType: ["text", "tel", "password"],
            colorMask: !1,
            androidHack: !1,
            definitions: {
                9: {
                    validator: "[0-9]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                a: {
                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                    cardinality: 1,
                    definitionSymbol: "*"
                },
                "*": {
                    validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
                    cardinality: 1
                }
            },
            ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
            isComplete: null,
            canClearPosition: ve.noop,
            postValidation: null,
            staticDefinitionSymbol: void 0,
            jitMasking: !1
        },
        masksCache: {},
        mask: function(e) {
            var n = this;
            return "string" == typeof e && (e = document.getElementById(e) || document.querySelectorAll(e)), e = e.nodeName ? [e] : e, ve.each(e, function(e, t) {
                var i = ve.extend(!0, {}, n.opts);
                ! function(i, e, a) {
                    function t(e, t) {
                        null !== (t = void 0 !== t ? t : i.getAttribute("data-inputmask-" + e)) && ("string" == typeof t && (0 === e.indexOf("on") ? t = window[t] : "false" === t ? t = !1 : "true" === t && (t = !0)), a[e] = t)
                    }
                    var n, r, o, s, l = i.getAttribute("data-inputmask");
                    if (l && "" !== l && (l = l.replace(new RegExp("'", "g"), '"'), r = JSON.parse("{" + l + "}")), r)
                        for (s in o = void 0, r)
                            if ("alias" === s.toLowerCase()) {
                                o = r[s];
                                break
                            }
                    for (n in t("alias", o), a.alias && u(a.alias, a, e), e) {
                        if (r)
                            for (s in o = void 0, r)
                                if (s.toLowerCase() === n.toLowerCase()) {
                                    o = r[s];
                                    break
                                }
                        t(n, o)
                    }
                    ve.extend(!0, e, a)
                }(t, i, ve.extend(!0, {}, n.userOptions));
                var a = r(i, n.noMasksCache);
                void 0 !== a && (void 0 !== t.inputmask && t.inputmask.remove(), t.inputmask = new he, t.inputmask.opts = i, t.inputmask.noMasksCache = n.noMasksCache, t.inputmask.userOptions = ve.extend(!0, {}, n.userOptions), (t.inputmask.el = t).inputmask.maskset = a, t.inputmask.isRTL = !1, ve.data(t, "_inputmask_opts", i), ge({
                    action: "mask",
                    el: t
                }))
            }), e && e[0] && e[0].inputmask || this
        },
        option: function(e) {
            return "string" == typeof e ? this.opts[e] : "object" == typeof e ? (ve.extend(this.opts, e), ve.extend(this.userOptions, e), this.el && (void 0 !== e.mask || void 0 !== e.alias ? this.mask(this.el) : (ve.data(this.el, "_inputmask_opts", this.opts), ge({
                action: "mask",
                el: this.el
            }))), this) : void 0
        },
        unmaskedvalue: function(e) {
            return ge({
                action: "unmaskedvalue",
                el: this.el,
                value: e
            }, this.el && this.el.inputmask ? this.el.inputmask.maskset : r(this.opts, this.noMasksCache), this.opts)
        },
        remove: function() {
            return this.el ? (ge({
                action: "remove",
                el: this.el
            }), this.el.inputmask = void 0, this.el) : void 0
        },
        getemptymask: function() {
            return ge({
                action: "getemptymask"
            }, this.maskset || r(this.opts, this.noMasksCache), this.opts)
        },
        hasMaskedValue: function() {
            return !this.opts.autoUnmask
        },
        isComplete: function() {
            return ge({
                action: "isComplete",
                el: this.el
            }, this.maskset || r(this.opts, this.noMasksCache), this.opts)
        },
        getmetadata: function() {
            return ge({
                action: "getmetadata"
            }, this.maskset || r(this.opts, this.noMasksCache), this.opts)
        },
        isValid: function(e) {
            return ge({
                action: "isValid",
                value: e
            }, this.maskset || r(this.opts, this.noMasksCache), this.opts)
        },
        format: function(e, t) {
            return ge({
                action: "format",
                value: e,
                metadata: t
            }, this.maskset || r(this.opts, this.noMasksCache), this.opts)
        }
    }, he.extendDefaults = function(e) {
        ve.extend(!0, he.prototype.defaults, e)
    }, he.extendDefinitions = function(e) {
        ve.extend(!0, he.prototype.defaults.definitions, e)
    }, he.extendAliases = function(e) {
        ve.extend(!0, he.prototype.defaults.aliases, e)
    }, he.format = function(e, t, i) {
        return he(t).format(e, i)
    }, he.unmask = function(e, t) {
        return he(t).unmaskedvalue(e)
    }, he.isValid = function(e, t) {
        return he(t).isValid(e)
    }, he.remove = function(e) {
        ve.each(e, function(e, t) {
            t.inputmask && t.inputmask.remove()
        })
    }, he.escapeRegex = function(e) {
        return e.replace(new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim"), "\\$1")
    }, he.keyCode = {
        ALT: 18,
        BACKSPACE: 8,
        CAPS_LOCK: 20,
        COMMA: 188,
        COMMAND: 91,
        COMMAND_LEFT: 91,
        COMMAND_RIGHT: 93,
        CONTROL: 17,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        INSERT: 45,
        LEFT: 37,
        MENU: 93,
        NUMPAD_ADD: 107,
        NUMPAD_DECIMAL: 110,
        NUMPAD_DIVIDE: 111,
        NUMPAD_ENTER: 108,
        NUMPAD_MULTIPLY: 106,
        NUMPAD_SUBTRACT: 109,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SHIFT: 16,
        SPACE: 32,
        TAB: 9,
        UP: 38,
        WINDOWS: 91
    };
    var ye, e = navigator.userAgent,
        ke = /mobile/i.test(e),
        xe = /iemobile/i.test(e),
        be = /iphone/i.test(e) && !xe,
        Pe = /android/i.test(e) && !xe;
    /android.*safari.*/i.test(e), window.Inputmask = he
}(jQuery),
function(n, r) {
    void 0 === n.fn.inputmask && (n.fn.inputmask = function(e, t) {
        var i, a = this[0];
        if (t = t || {}, "string" == typeof e) switch (e) {
            case "unmaskedvalue":
                return a && a.inputmask ? a.inputmask.unmaskedvalue() : n(a).val();
            case "remove":
                return this.each(function() {
                    this.inputmask && this.inputmask.remove()
                });
            case "getemptymask":
                return a && a.inputmask ? a.inputmask.getemptymask() : "";
            case "hasMaskedValue":
                return !(!a || !a.inputmask) && a.inputmask.hasMaskedValue();
            case "isComplete":
                return !a || !a.inputmask || a.inputmask.isComplete();
            case "getmetadata":
                return a && a.inputmask ? a.inputmask.getmetadata() : void 0;
            case "setvalue":
                n(a).val(t), a && void 0 !== a.inputmask && n(a).triggerHandler("setvalue");
                break;
            case "option":
                if ("string" != typeof t) return this.each(function() {
                    return void 0 !== this.inputmask ? this.inputmask.option(t) : void 0
                });
                if (a && void 0 !== a.inputmask) return a.inputmask.option(t);
                break;
            default:
                return t.alias = e, i = new r(t), this.each(function() {
                    i.mask(this)
                })
        } else {
            if ("object" == typeof e) return i = new r(e), void 0 === e.mask && void 0 === e.alias ? this.each(function() {
                return void 0 !== this.inputmask ? this.inputmask.option(e) : void i.mask(this)
            }) : this.each(function() {
                i.mask(this)
            });
            if (void 0 === e) return this.each(function() {
                (i = new r(t)).mask(this)
            })
        }
    }), n.fn.inputmask
}(jQuery, Inputmask),
function(o, s) {
    s.extendDefinitions({
        h: {
            validator: "[01][0-9]|2[0-3]",
            cardinality: 2,
            prevalidator: [{
                validator: "[0-2]",
                cardinality: 1
            }]
        },
        s: {
            validator: "[0-5][0-9]",
            cardinality: 2,
            prevalidator: [{
                validator: "[0-5]",
                cardinality: 1
            }]
        },
        d: {
            validator: "0[1-9]|[12][0-9]|3[01]",
            cardinality: 2,
            prevalidator: [{
                validator: "[0-3]",
                cardinality: 1
            }]
        },
        m: {
            validator: "0[1-9]|1[012]",
            cardinality: 2,
            prevalidator: [{
                validator: "[01]",
                cardinality: 1
            }]
        },
        y: {
            validator: "(19|20)\\d{2}",
            cardinality: 4,
            prevalidator: [{
                validator: "[12]",
                cardinality: 1
            }, {
                validator: "(19|20)",
                cardinality: 2
            }, {
                validator: "(19|20)\\d",
                cardinality: 3
            }]
        }
    }), s.extendAliases({
        "dd/mm/yyyy": {
            mask: "1/2/y",
            placeholder: "dd/mm/yyyy",
            regex: {
                val1pre: new RegExp("[0-3]"),
                val1: new RegExp("0[1-9]|[12][0-9]|3[01]"),
                val2pre: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[1-9]|[12][0-9]|3[01])" + t + "[01])")
                },
                val2: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[1-9]|[12][0-9])" + t + "(0[1-9]|1[012]))|(30" + t + "(0[13-9]|1[012]))|(31" + t + "(0[13578]|1[02]))")
                }
            },
            leapday: "29/02/",
            separator: "/",
            yearrange: {
                minyear: 1900,
                maxyear: 2099
            },
            isInYearRange: function(e, t, i) {
                if (isNaN(e)) return !1;
                var a = parseInt(e.concat(t.toString().slice(e.length))),
                    n = parseInt(e.concat(i.toString().slice(e.length)));
                return !isNaN(a) && (t <= a && a <= i) || !isNaN(n) && (t <= n && n <= i)
            },
            determinebaseyear: function(e, t, i) {
                var a = (new Date).getFullYear();
                if (a < e) return e;
                if (t < a) {
                    for (var n = t.toString().slice(0, 2), r = t.toString().slice(2, 4); t < n + i;) n--;
                    var o = n + r;
                    return o < e ? e : o
                }
                return a
            },
            onKeyDown: function(e, t, i, a) {
                var n = o(this);
                if (e.ctrlKey && e.keyCode === s.keyCode.RIGHT) {
                    var r = new Date;
                    n.val(r.getDate().toString() + (r.getMonth() + 1).toString() + r.getFullYear().toString()), n.trigger("setvalue")
                }
            },
            getFrontValue: function(e, t, i) {
                for (var a = 0, n = 0, r = 0; r < e.length && "2" !== e.charAt(r); r++) {
                    var o = i.definitions[e.charAt(r)];
                    o ? (a += n, n = o.cardinality) : n++
                }
                return t.join("").substr(a, n)
            },
            definitions: {
                1: {
                    validator: function(e, t, i, a, n) {
                        var r = n.regex.val1.test(e);
                        return a || r || e.charAt(1) !== n.separator && -1 === "-./".indexOf(e.charAt(1)) || !(r = n.regex.val1.test("0" + e.charAt(0))) ? r : (t.buffer[i - 1] = "0", {
                            refreshFromBuffer: {
                                start: i - 1,
                                end: i
                            },
                            pos: i,
                            c: e.charAt(0)
                        })
                    },
                    cardinality: 2,
                    prevalidator: [{
                        validator: function(e, t, i, a, n) {
                            var r = e;
                            isNaN(t.buffer[i + 1]) || (r += t.buffer[i + 1]);
                            var o = 1 === r.length ? n.regex.val1pre.test(r) : n.regex.val1.test(r);
                            if (!a && !o) {
                                if (o = n.regex.val1.test(e + "0")) return t.buffer[i] = e, t.buffer[++i] = "0", {
                                    pos: i,
                                    c: "0"
                                };
                                if (o = n.regex.val1.test("0" + e)) return t.buffer[i] = "0", {
                                    pos: ++i
                                }
                            }
                            return o
                        },
                        cardinality: 1
                    }]
                },
                2: {
                    validator: function(e, t, i, a, n) {
                        var r = n.getFrontValue(t.mask, t.buffer, n); - 1 !== r.indexOf(n.placeholder[0]) && (r = "01" + n.separator);
                        var o = n.regex.val2(n.separator).test(r + e);
                        if (!a && !o && (e.charAt(1) === n.separator || -1 !== "-./".indexOf(e.charAt(1))) && (o = n.regex.val2(n.separator).test(r + "0" + e.charAt(0)))) return t.buffer[i - 1] = "0", {
                            refreshFromBuffer: {
                                start: i - 1,
                                end: i
                            },
                            pos: i,
                            c: e.charAt(0)
                        };
                        if (n.mask.indexOf("2") === n.mask.length - 1 && o) {
                            if (t.buffer.join("").substr(4, 4) + e !== n.leapday) return !0;
                            var s = parseInt(t.buffer.join("").substr(0, 4), 10);
                            return s % 4 == 0 && (s % 100 != 0 || s % 400 == 0)
                        }
                        return o
                    },
                    cardinality: 2,
                    prevalidator: [{
                        validator: function(e, t, i, a, n) {
                            isNaN(t.buffer[i + 1]) || (e += t.buffer[i + 1]);
                            var r = n.getFrontValue(t.mask, t.buffer, n); - 1 !== r.indexOf(n.placeholder[0]) && (r = "01" + n.separator);
                            var o = 1 === e.length ? n.regex.val2pre(n.separator).test(r + e) : n.regex.val2(n.separator).test(r + e);
                            return a || o || !(o = n.regex.val2(n.separator).test(r + "0" + e)) ? o : (t.buffer[i] = "0", {
                                pos: ++i
                            })
                        },
                        cardinality: 1
                    }]
                },
                y: {
                    validator: function(e, t, i, a, n) {
                        if (n.isInYearRange(e, n.yearrange.minyear, n.yearrange.maxyear)) {
                            if (t.buffer.join("").substr(0, 6) !== n.leapday) return !0;
                            var r = parseInt(e, 10);
                            return r % 4 == 0 && (r % 100 != 0 || r % 400 == 0)
                        }
                        return !1
                    },
                    cardinality: 4,
                    prevalidator: [{
                        validator: function(e, t, i, a, n) {
                            var r = n.isInYearRange(e, n.yearrange.minyear, n.yearrange.maxyear);
                            if (!a && !r) {
                                var o = n.determinebaseyear(n.yearrange.minyear, n.yearrange.maxyear, e + "0").toString().slice(0, 1);
                                if (r = n.isInYearRange(o + e, n.yearrange.minyear, n.yearrange.maxyear)) return t.buffer[i++] = o.charAt(0), {
                                    pos: i
                                };
                                if (o = n.determinebaseyear(n.yearrange.minyear, n.yearrange.maxyear, e + "0").toString().slice(0, 2), r = n.isInYearRange(o + e, n.yearrange.minyear, n.yearrange.maxyear)) return t.buffer[i++] = o.charAt(0), t.buffer[i++] = o.charAt(1), {
                                    pos: i
                                }
                            }
                            return r
                        },
                        cardinality: 1
                    }, {
                        validator: function(e, t, i, a, n) {
                            var r = n.isInYearRange(e, n.yearrange.minyear, n.yearrange.maxyear);
                            if (!a && !r) {
                                var o = n.determinebaseyear(n.yearrange.minyear, n.yearrange.maxyear, e).toString().slice(0, 2);
                                if (r = n.isInYearRange(e[0] + o[1] + e[1], n.yearrange.minyear, n.yearrange.maxyear)) return t.buffer[i++] = o.charAt(1), {
                                    pos: i
                                };
                                if (o = n.determinebaseyear(n.yearrange.minyear, n.yearrange.maxyear, e).toString().slice(0, 2), n.isInYearRange(o + e, n.yearrange.minyear, n.yearrange.maxyear))
                                    if (t.buffer.join("").substr(0, 6) !== n.leapday) r = !0;
                                    else {
                                        var s = parseInt(e, 10);
                                        r = s % 4 == 0 && (s % 100 != 0 || s % 400 == 0)
                                    }
                                else r = !1;
                                if (r) return t.buffer[i - 1] = o.charAt(0), t.buffer[i++] = o.charAt(1), t.buffer[i++] = e.charAt(0), {
                                    refreshFromBuffer: {
                                        start: i - 3,
                                        end: i
                                    },
                                    pos: i
                                }
                            }
                            return r
                        },
                        cardinality: 2
                    }, {
                        validator: function(e, t, i, a, n) {
                            return n.isInYearRange(e, n.yearrange.minyear, n.yearrange.maxyear)
                        },
                        cardinality: 3
                    }]
                }
            },
            insertMode: !1,
            autoUnmask: !1
        },
        "mm/dd/yyyy": {
            placeholder: "mm/dd/yyyy",
            alias: "dd/mm/yyyy",
            regex: {
                val2pre: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[13-9]|1[012])" + t + "[0-3])|(02" + t + "[0-2])")
                },
                val2: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[1-9]|1[012])" + t + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + t + "30)|((0[13578]|1[02])" + t + "31)")
                },
                val1pre: new RegExp("[01]"),
                val1: new RegExp("0[1-9]|1[012]")
            },
            leapday: "02/29/",
            onKeyDown: function(e, t, i, a) {
                var n = o(this);
                if (e.ctrlKey && e.keyCode === s.keyCode.RIGHT) {
                    var r = new Date;
                    n.val((r.getMonth() + 1).toString() + r.getDate().toString() + r.getFullYear().toString()), n.trigger("setvalue")
                }
            }
        },
        "yyyy/mm/dd": {
            mask: "y/1/2",
            placeholder: "yyyy/mm/dd",
            alias: "mm/dd/yyyy",
            leapday: "/02/29",
            onKeyDown: function(e, t, i, a) {
                var n = o(this);
                if (e.ctrlKey && e.keyCode === s.keyCode.RIGHT) {
                    var r = new Date;
                    n.val(r.getFullYear().toString() + (r.getMonth() + 1).toString() + r.getDate().toString()), n.trigger("setvalue")
                }
            }
        },
        "dd.mm.yyyy": {
            mask: "1.2.y",
            placeholder: "dd.mm.yyyy",
            leapday: "29.02.",
            separator: ".",
            alias: "dd/mm/yyyy"
        },
        "dd-mm-yyyy": {
            mask: "1-2-y",
            placeholder: "dd-mm-yyyy",
            leapday: "29-02-",
            separator: "-",
            alias: "dd/mm/yyyy"
        },
        "mm.dd.yyyy": {
            mask: "1.2.y",
            placeholder: "mm.dd.yyyy",
            leapday: "02.29.",
            separator: ".",
            alias: "mm/dd/yyyy"
        },
        "mm-dd-yyyy": {
            mask: "1-2-y",
            placeholder: "mm-dd-yyyy",
            leapday: "02-29-",
            separator: "-",
            alias: "mm/dd/yyyy"
        },
        "yyyy.mm.dd": {
            mask: "y.1.2",
            placeholder: "yyyy.mm.dd",
            leapday: ".02.29",
            separator: ".",
            alias: "yyyy/mm/dd"
        },
        "yyyy-mm-dd": {
            mask: "y-1-2",
            placeholder: "yyyy-mm-dd",
            leapday: "-02-29",
            separator: "-",
            alias: "yyyy/mm/dd"
        },
        datetime: {
            mask: "1/2/y h:s",
            placeholder: "dd/mm/yyyy hh:mm",
            alias: "dd/mm/yyyy",
            regex: {
                hrspre: new RegExp("[012]"),
                hrs24: new RegExp("2[0-4]|1[3-9]"),
                hrs: new RegExp("[01][0-9]|2[0-4]"),
                ampm: new RegExp("^[a|p|A|P][m|M]"),
                mspre: new RegExp("[0-5]"),
                ms: new RegExp("[0-5][0-9]")
            },
            timeseparator: ":",
            hourFormat: "24",
            definitions: {
                h: {
                    validator: function(e, t, i, a, n) {
                        if ("24" === n.hourFormat && 24 === parseInt(e, 10)) return t.buffer[i - 1] = "0", {
                            refreshFromBuffer: {
                                start: i - 1,
                                end: i
                            },
                            c: t.buffer[i] = "0"
                        };
                        var r = n.regex.hrs.test(e);
                        if (!a && !r && (e.charAt(1) === n.timeseparator || -1 !== "-.:".indexOf(e.charAt(1))) && (r = n.regex.hrs.test("0" + e.charAt(0)))) return t.buffer[i - 1] = "0", t.buffer[i] = e.charAt(0), {
                            refreshFromBuffer: {
                                start: ++i - 2,
                                end: i
                            },
                            pos: i,
                            c: n.timeseparator
                        };
                        if (r && "24" !== n.hourFormat && n.regex.hrs24.test(e)) {
                            var o = parseInt(e, 10);
                            return t.buffer[i + 5] = 24 === o ? "a" : "p", t.buffer[i + 6] = "m", (o -= 12) < 10 ? (t.buffer[i] = o.toString(), t.buffer[i - 1] = "0") : (t.buffer[i] = o.toString().charAt(1), t.buffer[i - 1] = o.toString().charAt(0)), {
                                refreshFromBuffer: {
                                    start: i - 1,
                                    end: i + 6
                                },
                                c: t.buffer[i]
                            }
                        }
                        return r
                    },
                    cardinality: 2,
                    prevalidator: [{
                        validator: function(e, t, i, a, n) {
                            var r = n.regex.hrspre.test(e);
                            return a || r || !(r = n.regex.hrs.test("0" + e)) ? r : (t.buffer[i] = "0", {
                                pos: ++i
                            })
                        },
                        cardinality: 1
                    }]
                },
                s: {
                    validator: "[0-5][0-9]",
                    cardinality: 2,
                    prevalidator: [{
                        validator: function(e, t, i, a, n) {
                            var r = n.regex.mspre.test(e);
                            return a || r || !(r = n.regex.ms.test("0" + e)) ? r : (t.buffer[i] = "0", {
                                pos: ++i
                            })
                        },
                        cardinality: 1
                    }]
                },
                t: {
                    validator: function(e, t, i, a, n) {
                        return n.regex.ampm.test(e + "m")
                    },
                    casing: "lower",
                    cardinality: 1
                }
            },
            insertMode: !1,
            autoUnmask: !1
        },
        datetime12: {
            mask: "1/2/y h:s t\\m",
            placeholder: "dd/mm/yyyy hh:mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "mm/dd/yyyy hh:mm xm": {
            mask: "1/2/y h:s t\\m",
            placeholder: "mm/dd/yyyy hh:mm xm",
            alias: "datetime12",
            regex: {
                val2pre: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[13-9]|1[012])" + t + "[0-3])|(02" + t + "[0-2])")
                },
                val2: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[1-9]|1[012])" + t + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + t + "30)|((0[13578]|1[02])" + t + "31)")
                },
                val1pre: new RegExp("[01]"),
                val1: new RegExp("0[1-9]|1[012]")
            },
            leapday: "02/29/",
            onKeyDown: function(e, t, i, a) {
                var n = o(this);
                if (e.ctrlKey && e.keyCode === s.keyCode.RIGHT) {
                    var r = new Date;
                    n.val((r.getMonth() + 1).toString() + r.getDate().toString() + r.getFullYear().toString()), n.trigger("setvalue")
                }
            }
        },
        "hh:mm t": {
            mask: "h:s t\\m",
            placeholder: "hh:mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "h:s t": {
            mask: "h:s t\\m",
            placeholder: "hh:mm xm",
            alias: "datetime",
            hourFormat: "12"
        },
        "hh:mm:ss": {
            mask: "h:s:s",
            placeholder: "hh:mm:ss",
            alias: "datetime",
            autoUnmask: !1
        },
        "hh:mm": {
            mask: "h:s",
            placeholder: "hh:mm",
            alias: "datetime",
            autoUnmask: !1
        },
        date: {
            alias: "dd/mm/yyyy"
        },
        "mm/yyyy": {
            mask: "1/y",
            placeholder: "mm/yyyy",
            leapday: "donotuse",
            separator: "/",
            alias: "mm/dd/yyyy"
        },
        shamsi: {
            regex: {
                val2pre: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[1-9]|1[012])" + t + "[0-3])")
                },
                val2: function(e) {
                    var t = s.escapeRegex.call(this, e);
                    return new RegExp("((0[1-9]|1[012])" + t + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + t + "30)|((0[1-6])" + t + "31)")
                },
                val1pre: new RegExp("[01]"),
                val1: new RegExp("0[1-9]|1[012]")
            },
            yearrange: {
                minyear: 1300,
                maxyear: 1499
            },
            mask: "y/1/2",
            leapday: "/12/30",
            placeholder: "yyyy/mm/dd",
            alias: "mm/dd/yyyy",
            clearIncomplete: !0
        }
    })
}(jQuery, Inputmask),
function(e, t) {
    t.extendDefinitions({
        A: {
            validator: "[A-Za-zА-яЁёÀ-ÿµ]",
            cardinality: 1,
            casing: "upper"
        },
        "&": {
            validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
            cardinality: 1,
            casing: "upper"
        },
        "#": {
            validator: "[0-9A-Fa-f]",
            cardinality: 1,
            casing: "upper"
        }
    }), t.extendAliases({
        url: {
            definitions: {
                i: {
                    validator: ".",
                    cardinality: 1
                }
            },
            mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}",
            insertMode: !1,
            autoUnmask: !1
        },
        ip: {
            mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]",
            definitions: {
                i: {
                    validator: function(e, t, i, a, n) {
                        return e = -1 < i - 1 && "." !== t.buffer[i - 1] ? (e = t.buffer[i - 1] + e, -1 < i - 2 && "." !== t.buffer[i - 2] ? t.buffer[i - 2] + e : "0" + e) : "00" + e, new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(e)
                    },
                    cardinality: 1
                }
            },
            onUnMask: function(e, t, i) {
                return e
            }
        },
        email: {
            mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,64}]@*{1,64}[.*{2,64}][.*{2,6}][.*{1,2}]",
            greedy: !1,
            onBeforePaste: function(e, t) {
                return (e = e.toLowerCase()).replace("mailto:", "")
            },
            definitions: {
                "*": {
                    validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]",
                    cardinality: 1,
                    casing: "lower"
                }
            },
            onUnMask: function(e, t, i) {
                return e
            }
        },
        mac: {
            mask: "##:##:##:##:##:##"
        }
    })
}(jQuery, Inputmask),
function(h, g) {
    g.extendAliases({
        numeric: {
            mask: function(a) {
                function e(e) {
                    for (var t = "", i = 0; i < e.length; i++) t += a.definitions[e.charAt(i)] ? "\\" + e.charAt(i) : e.charAt(i);
                    return t
                }
                if (0 !== a.repeat && isNaN(a.integerDigits) && (a.integerDigits = a.repeat), a.repeat = 0, a.groupSeparator === a.radixPoint && ("." === a.radixPoint ? a.groupSeparator = "," : "," === a.radixPoint ? a.groupSeparator = "." : a.groupSeparator = ""), " " === a.groupSeparator && (a.skipOptionalPartCharacter = void 0), a.autoGroup = a.autoGroup && "" !== a.groupSeparator, a.autoGroup && ("string" == typeof a.groupSize && isFinite(a.groupSize) && (a.groupSize = parseInt(a.groupSize)), isFinite(a.integerDigits))) {
                    var t = Math.floor(a.integerDigits / a.groupSize),
                        i = a.integerDigits % a.groupSize;
                    a.integerDigits = parseInt(a.integerDigits) + (0 == i ? t - 1 : t), a.integerDigits < 1 && (a.integerDigits = "*")
                }
                1 < a.placeholder.length && (a.placeholder = a.placeholder.charAt(0)), a.radixFocus = a.radixFocus && "" !== a.placeholder && !0 === a.integerOptional, a.definitions[";"] = a.definitions["~"], a.definitions[";"].definitionSymbol = "~", 1 == a.numericInput && (a.radixFocus = !1, a.digitsOptional = !1, isNaN(a.digits) && (a.digits = 2), a.decimalProtect = !1);
                var n = e(a.prefix);
                return n += "[+]", n += !0 === a.integerOptional ? "~{1," + a.integerDigits + "}" : "~{" + a.integerDigits + "}", void 0 !== a.digits && (isNaN(a.digits) || 0 < parseInt(a.digits)) && (n += a.digitsOptional ? "[" + (a.decimalProtect ? ":" : a.radixPoint) + ";{1," + a.digits + "}]" : (a.decimalProtect ? ":" : a.radixPoint) + ";{" + a.digits + "}"), "" !== a.negationSymbol.back && (n += "[-]"), n += e(a.suffix), a.greedy = !1, n
            },
            placeholder: "",
            greedy: !1,
            digits: "*",
            digitsOptional: !0,
            radixPoint: ".",
            radixFocus: !0,
            groupSize: 3,
            groupSeparator: "",
            autoGroup: !1,
            allowPlus: !0,
            allowMinus: !0,
            negationSymbol: {
                front: "-",
                back: ""
            },
            integerDigits: "+",
            integerOptional: !0,
            prefix: "",
            suffix: "",
            rightAlign: !0,
            decimalProtect: !0,
            min: null,
            max: null,
            step: 1,
            insertMode: !0,
            autoUnmask: !1,
            unmaskAsNumber: !1,
            postFormat: function(e, t, i, a) {
                !0 === a.numericInput && (e = e.reverse(), isFinite(t) && (t = e.join("").length - t - 1));
                var n, r, o = !1;
                e.length >= a.suffix.length && e.join("").indexOf(a.suffix) === e.length - a.suffix.length && (e.length = e.length - a.suffix.length, o = !0);
                var s = !1,
                    l = e[t = t >= e.length ? e.length - 1 : t < a.prefix.length ? a.prefix.length : t];
                if ("" === a.groupSeparator || !0 !== a.numericInput && -1 !== h.inArray(a.radixPoint, e) && t > h.inArray(a.radixPoint, e) || new RegExp("[" + g.escapeRegex(a.negationSymbol.front) + "+]").test(l)) {
                    if (o)
                        for (n = 0, r = a.suffix.length; n < r; n++) e.push(a.suffix.charAt(n));
                    return {
                        pos: t
                    }
                }
                var u = e.slice();
                l === a.groupSeparator && (u.splice(t--, 1), l = u[t]), i ? l !== a.radixPoint && (u[t] = "?") : u.splice(t, 0, "?");
                var c = u.join(""),
                    f = c;
                if (0 < c.length && a.autoGroup || i && -1 !== c.indexOf(a.groupSeparator)) {
                    var d = g.escapeRegex(a.groupSeparator);
                    s = 0 === c.indexOf(a.groupSeparator);
                    var p = (c = c.replace(new RegExp(d, "g"), "")).split(a.radixPoint);
                    if ((c = "" === a.radixPoint ? c : p[0]) !== a.prefix + "?0" && c.length >= a.groupSize + a.prefix.length)
                        for (var m = new RegExp("([-+]?[\\d?]+)([\\d?]{" + a.groupSize + "})"); m.test(c);) c = (c = c.replace(m, "$1" + a.groupSeparator + "$2")).replace(a.groupSeparator + a.groupSeparator, a.groupSeparator);
                    "" !== a.radixPoint && 1 < p.length && (c += a.radixPoint + p[1])
                }
                for (s = f !== c, e.length = c.length, n = 0, r = c.length; n < r; n++) e[n] = c.charAt(n);
                var v = h.inArray("?", e);
                if (-1 === v && l === a.radixPoint && (v = h.inArray(a.radixPoint, e)), i ? e[v] = l : e.splice(v, 1), !s && o)
                    for (n = 0, r = a.suffix.length; n < r; n++) e.push(a.suffix.charAt(n));
                return v = a.numericInput && isFinite(t) ? e.join("").length - v - 1 : v, a.numericInput && (e = e.reverse(), h.inArray(a.radixPoint, e) < v && e.join("").length - a.suffix.length !== v && (v -= 1)), {
                    pos: v,
                    refreshFromBuffer: s,
                    buffer: e
                }
            },
            onBeforeWrite: function(e, t, i, a) {
                if (e && ("blur" === e.type || "checkval" === e.type)) {
                    var n = t.join(""),
                        r = n.replace(a.prefix, "");
                    if (r = (r = r.replace(a.suffix, "")).replace(new RegExp(g.escapeRegex(a.groupSeparator), "g"), ""), "," === a.radixPoint && (r = r.replace(g.escapeRegex(a.radixPoint), ".")), isFinite(r) && isFinite(a.min) && parseFloat(r) < parseFloat(a.min)) return h.extend(!0, {
                        refreshFromBuffer: !0,
                        buffer: (a.prefix + a.min).split("")
                    }, a.postFormat((a.prefix + a.min).split(""), 0, !0, a));
                    if (!0 !== a.numericInput) {
                        var o = "" !== a.radixPoint ? t.join("").split(a.radixPoint) : [t.join("")],
                            s = o[0].match(a.regex.integerPart(a)),
                            l = 2 === o.length ? o[1].match(a.regex.integerNPart(a)) : void 0;
                        if (s) {
                            s[0] !== a.negationSymbol.front + "0" && s[0] !== a.negationSymbol.front && "+" !== s[0] || void 0 !== l && !l[0].match(/^0+$/) || t.splice(s.index, 1);
                            var u = h.inArray(a.radixPoint, t);
                            if (-1 !== u) {
                                if (isFinite(a.digits) && !a.digitsOptional) {
                                    for (var c = 1; c <= a.digits; c++)(void 0 === t[u + c] || t[u + c] === a.placeholder.charAt(0)) && (t[u + c] = "0");
                                    return {
                                        refreshFromBuffer: n !== t.join(""),
                                        buffer: t
                                    }
                                }
                                if (u === t.length - a.suffix.length - 1) return t.splice(u, 1), {
                                    refreshFromBuffer: !0,
                                    buffer: t
                                }
                            }
                        }
                    }
                }
                if (a.autoGroup) {
                    var f = a.postFormat(t, a.numericInput ? i : i - 1, !0, a);
                    return f.caret = i <= a.prefix.length ? f.pos : f.pos + 1, f
                }
            },
            regex: {
                integerPart: function(e) {
                    return new RegExp("[" + g.escapeRegex(e.negationSymbol.front) + "+]?\\d+")
                },
                integerNPart: function(e) {
                    return new RegExp("[\\d" + g.escapeRegex(e.groupSeparator) + "]+")
                }
            },
            signHandler: function(e, t, i, a, n) {
                if (!a && n.allowMinus && "-" === e || n.allowPlus && "+" === e) {
                    var r = t.buffer.join("").match(n.regex.integerPart(n));
                    if (r && 0 < r[0].length) return t.buffer[r.index] === ("-" === e ? "+" : n.negationSymbol.front) ? "-" === e ? "" !== n.negationSymbol.back ? {
                        pos: r.index,
                        c: n.negationSymbol.front,
                        remove: r.index,
                        caret: i,
                        insert: {
                            pos: t.buffer.length - n.suffix.length - 1,
                            c: n.negationSymbol.back
                        }
                    } : {
                        pos: r.index,
                        c: n.negationSymbol.front,
                        remove: r.index,
                        caret: i
                    } : "" !== n.negationSymbol.back ? {
                        pos: r.index,
                        c: "+",
                        remove: [r.index, t.buffer.length - n.suffix.length - 1],
                        caret: i
                    } : {
                        pos: r.index,
                        c: "+",
                        remove: r.index,
                        caret: i
                    } : t.buffer[r.index] === ("-" === e ? n.negationSymbol.front : "+") ? "-" === e && "" !== n.negationSymbol.back ? {
                        remove: [r.index, t.buffer.length - n.suffix.length - 1],
                        caret: i - 1
                    } : {
                        remove: r.index,
                        caret: i - 1
                    } : "-" === e ? "" !== n.negationSymbol.back ? {
                        pos: r.index,
                        c: n.negationSymbol.front,
                        caret: i + 1,
                        insert: {
                            pos: t.buffer.length - n.suffix.length,
                            c: n.negationSymbol.back
                        }
                    } : {
                        pos: r.index,
                        c: n.negationSymbol.front,
                        caret: i + 1
                    } : {
                        pos: r.index,
                        c: e,
                        caret: i + 1
                    }
                }
                return !1
            },
            radixHandler: function(e, t, i, a, n) {
                if (!a && (-1 !== h.inArray(e, [",", "."]) && (e = n.radixPoint), e === n.radixPoint && void 0 !== n.digits && (isNaN(n.digits) || 0 < parseInt(n.digits)))) {
                    var r = h.inArray(n.radixPoint, t.buffer),
                        o = t.buffer.join("").match(n.regex.integerPart(n));
                    if (-1 !== r && t.validPositions[r]) return t.validPositions[r - 1] ? {
                        caret: r + 1
                    } : {
                        pos: o.index,
                        c: o[0],
                        caret: r + 1
                    };
                    if (!o || "0" === o[0] && o.index + 1 !== i) return t.buffer[o ? o.index : i] = "0", {
                        pos: (o ? o.index : i) + 1,
                        c: n.radixPoint
                    }
                }
                return !1
            },
            leadingZeroHandler: function(e, t, i, a, n) {
                if (!0 === n.numericInput) {
                    if ("0" === t.buffer[t.buffer.length - n.prefix.length - 1]) return {
                        pos: i,
                        remove: t.buffer.length - n.prefix.length - 1
                    }
                } else {
                    var r = t.buffer.join("").match(n.regex.integerNPart(n)),
                        o = h.inArray(n.radixPoint, t.buffer);
                    if (r && !a && (-1 === o || i <= o))
                        if (0 === r[0].indexOf("0")) {
                            i < n.prefix.length && (i = r.index);
                            var s = h.inArray(n.radixPoint, t._buffer),
                                l = t._buffer && t.buffer.slice(o).join("") === t._buffer.slice(s).join("") || 0 === parseInt(t.buffer.slice(o + 1).join("")),
                                u = t._buffer && t.buffer.slice(r.index, o).join("") === t._buffer.slice(n.prefix.length, s).join("") || "0" === t.buffer.slice(r.index, o).join("");
                            if (-1 === o || l && u) return t.buffer.splice(r.index, 1), {
                                pos: i = i > r.index ? i - 1 : r.index,
                                remove: r.index
                            };
                            if (r.index + 1 === i || "0" === e) return t.buffer.splice(r.index, 1), {
                                pos: i = r.index,
                                remove: r.index
                            }
                        } else if ("0" === e && i <= r.index && r[0] !== n.groupSeparator) return !1
                }
                return !0
            },
            postValidation: function(e, t, i) {
                var a = !0,
                    n = (i.numericInput ? e.slice().reverse().join("") : e.join("")).replace(i.prefix, "");
                return n = (n = n.replace(i.suffix, "")).replace(new RegExp(g.escapeRegex(i.groupSeparator), "g"), ""), "," === i.radixPoint && (n = n.replace(g.escapeRegex(i.radixPoint), ".")), n = (n = (n = n.replace(new RegExp("^" + g.escapeRegex(i.negationSymbol.front)), "-")).replace(new RegExp(g.escapeRegex(i.negationSymbol.back) + "$"), "")) === i.negationSymbol.front ? n + "0" : n, isFinite(n) && (null !== i.max && isFinite(i.max) && (n = parseFloat(n) > parseFloat(i.max) ? i.max : n, a = i.postFormat((i.prefix + n).split(""), 0, !0, i)), null !== i.min && isFinite(i.min) && (n = parseFloat(n) < parseFloat(i.min) ? i.min : n, a = i.postFormat((i.prefix + n).split(""), 0, !0, i))), a
            },
            definitions: {
                "~": {
                    validator: function(e, t, i, a, n) {
                        var r = n.signHandler(e, t, i, a, n);
                        if (!r && (!(r = n.radixHandler(e, t, i, a, n)) && (!0 === (r = a ? new RegExp("[0-9" + g.escapeRegex(n.groupSeparator) + "]").test(e) : new RegExp("[0-9]").test(e)) && !0 === (r = n.leadingZeroHandler(e, t, i, a, n))))) {
                            var o = h.inArray(n.radixPoint, t.buffer);
                            r = -1 !== o && !1 === n.digitsOptional && !0 !== n.numericInput && o < i && !a ? {
                                pos: i,
                                remove: i
                            } : {
                                pos: i
                            }
                        }
                        return r
                    },
                    cardinality: 1,
                    prevalidator: null
                },
                "+": {
                    validator: function(e, t, i, a, n) {
                        var r = n.signHandler(e, t, i, a, n);
                        return !r && (a && n.allowMinus && e === n.negationSymbol.front || n.allowMinus && "-" === e || n.allowPlus && "+" === e) && (r = "-" !== e || ("" !== n.negationSymbol.back ? {
                            pos: i,
                            c: "-" === e ? n.negationSymbol.front : "+",
                            caret: i + 1,
                            insert: {
                                pos: t.buffer.length,
                                c: n.negationSymbol.back
                            }
                        } : {
                            pos: i,
                            c: "-" === e ? n.negationSymbol.front : "+",
                            caret: i + 1
                        })), r
                    },
                    cardinality: 1,
                    prevalidator: null,
                    placeholder: ""
                },
                "-": {
                    validator: function(e, t, i, a, n) {
                        var r = n.signHandler(e, t, i, a, n);
                        return !r && a && n.allowMinus && e === n.negationSymbol.back && (r = !0), r
                    },
                    cardinality: 1,
                    prevalidator: null,
                    placeholder: ""
                },
                ":": {
                    validator: function(e, t, i, a, n) {
                        var r = n.signHandler(e, t, i, a, n);
                        if (!r) {
                            var o = "[" + g.escapeRegex(n.radixPoint) + ",\\.]";
                            (r = new RegExp(o).test(e)) && t.validPositions[i] && t.validPositions[i].match.placeholder === n.radixPoint && (r = {
                                caret: i + 1
                            })
                        }
                        return r ? {
                            c: n.radixPoint
                        } : r
                    },
                    cardinality: 1,
                    prevalidator: null,
                    placeholder: function(e) {
                        return e.radixPoint
                    }
                }
            },
            onUnMask: function(e, t, i) {
                var a = e.replace(i.prefix, "");
                return a = (a = a.replace(i.suffix, "")).replace(new RegExp(g.escapeRegex(i.groupSeparator), "g"), ""), i.unmaskAsNumber ? ("" !== i.radixPoint && -1 !== a.indexOf(i.radixPoint) && (a = a.replace(g.escapeRegex.call(this, i.radixPoint), ".")), Number(a)) : a
            },
            isComplete: function(e, t) {
                var i = e.join(""),
                    a = e.slice();
                if (t.postFormat(a, 0, !0, t), a.join("") !== i) return !1;
                var n = i.replace(t.prefix, "");
                return n = (n = n.replace(t.suffix, "")).replace(new RegExp(g.escapeRegex(t.groupSeparator), "g"), ""), "," === t.radixPoint && (n = n.replace(g.escapeRegex(t.radixPoint), ".")), isFinite(n)
            },
            onBeforeMask: function(e, t) {
                if ("" !== t.radixPoint && isFinite(e)) e = e.toString().replace(".", t.radixPoint);
                else {
                    var i = e.match(/,/g),
                        a = e.match(/\./g);
                    e = a && i ? a.length > i.length ? (e = e.replace(/\./g, "")).replace(",", t.radixPoint) : i.length > a.length ? (e = e.replace(/,/g, "")).replace(".", t.radixPoint) : e.indexOf(".") < e.indexOf(",") ? e.replace(/\./g, "") : e = e.replace(/,/g, "") : e.replace(new RegExp(g.escapeRegex(t.groupSeparator), "g"), "")
                }
                if (0 === t.digits && (-1 !== e.indexOf(".") ? e = e.substring(0, e.indexOf(".")) : -1 !== e.indexOf(",") && (e = e.substring(0, e.indexOf(",")))), "" !== t.radixPoint && isFinite(t.digits) && -1 !== e.indexOf(t.radixPoint)) {
                    var n = e.split(t.radixPoint)[1].match(new RegExp("\\d*"))[0];
                    if (parseInt(t.digits) < n.toString().length) {
                        var r = Math.pow(10, parseInt(t.digits));
                        e = e.replace(g.escapeRegex(t.radixPoint), "."), e = (e = Math.round(parseFloat(e) * r) / r).toString().replace(".", t.radixPoint)
                    }
                }
                return e.toString()
            },
            canClearPosition: function(e, t, i, a, n) {
                var r = e.validPositions[t].input,
                    o = r !== n.radixPoint || null !== e.validPositions[t].match.fn && !1 === n.decimalProtect || isFinite(r) || t === i || r === n.groupSeparator || r === n.negationSymbol.front || r === n.negationSymbol.back;
                if (o && isFinite(r)) {
                    var s, l = h.inArray(n.radixPoint, e.buffer),
                        u = !1;
                    if (void 0 === e.validPositions[l] && (e.validPositions[l] = {
                            input: n.radixPoint
                        }, u = !0), !a && e.buffer) {
                        var c = t + 1;
                        if (null == (s = e.buffer.join("").substr(0, t).match(n.regex.integerNPart(n))) || 0 === parseInt(s[0].replace(new RegExp(g.escapeRegex(n.groupSeparator), "g"), "")))
                            for (; e.validPositions[c] && (e.validPositions[c].input === n.groupSeparator || "0" === e.validPositions[c].input);) delete e.validPositions[c], c++
                    }
                    var f = [];
                    for (var d in e.validPositions) void 0 !== e.validPositions[d].input && f.push(e.validPositions[d].input);
                    if (u && delete e.validPositions[l], 0 < l) {
                        var p = f.join("");
                        if (s = p.match(n.regex.integerNPart(n)))
                            if (t <= l)
                                if (0 === s[0].indexOf("0")) o = s.index !== t || "0" === n.placeholder;
                                else {
                                    var m = parseInt(s[0].replace(new RegExp(g.escapeRegex(n.groupSeparator), "g"), "")),
                                        v = parseInt(p.split(n.radixPoint)[1]);
                                    m < 10 && e.validPositions[t] && ("0" !== n.placeholder || 0 < v) && (e.validPositions[t].input = "0", e.p = n.prefix.length + 1, o = !1)
                                }
                        else 0 === s[0].indexOf("0") && 3 === p.length && (o = !(e.validPositions = {}))
                    }
                }
                return o
            },
            onKeyDown: function(e, t, i, a) {
                var n = h(this);
                if (e.ctrlKey) switch (e.keyCode) {
                    case g.keyCode.UP:
                        n.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(a.step)), n.trigger("setvalue");
                        break;
                    case g.keyCode.DOWN:
                        n.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(a.step)), n.trigger("setvalue")
                }
            }
        },
        currency: {
            prefix: "$ ",
            groupSeparator: ",",
            alias: "numeric",
            placeholder: "0",
            autoGroup: !0,
            digits: 2,
            digitsOptional: !1,
            clearMaskOnLostFocus: !1
        },
        decimal: {
            alias: "numeric"
        },
        integer: {
            alias: "numeric",
            digits: 0,
            radixPoint: ""
        },
        percentage: {
            alias: "numeric",
            digits: 2,
            radixPoint: ".",
            placeholder: "0",
            autoGroup: !1,
            min: 0,
            max: 100,
            suffix: " %",
            allowPlus: !1,
            allowMinus: !1
        }
    })
}(jQuery, Inputmask),
function(e, t) {
    t.extendAliases({
        phone: {
            url: "phone-codes/phone-codes.js",
            countrycode: "",
            phoneCodeCache: {},
            mask: function(a) {
                if (void 0 === a.phoneCodeCache[a.url]) {
                    var t = [];
                    a.definitions["#"] = a.definitions[9], e.ajax({
                        url: a.url,
                        async: !1,
                        type: "get",
                        dataType: "json",
                        success: function(e) {
                            t = e
                        },
                        error: function(e, t, i) {
                            alert(i + " - " + a.url)
                        }
                    }), a.phoneCodeCache[a.url] = t.sort(function(e, t) {
                        return (e.mask || e) < (t.mask || t) ? -1 : 1
                    })
                }
                return a.phoneCodeCache[a.url]
            },
            keepStatic: !1,
            nojumps: !0,
            nojumpsThreshold: 1,
            onBeforeMask: function(e, t) {
                var i = e.replace(/^0{1,2}/, "").replace(/[\s]/g, "");
                return (1 < i.indexOf(t.countrycode) || -1 === i.indexOf(t.countrycode)) && (i = "+" + t.countrycode + i), i
            }
        },
        phonebe: {
            alias: "phone",
            url: "phone-codes/phone-be.js",
            countrycode: "32",
            nojumpsThreshold: 4
        }
    })
}(jQuery, Inputmask),
function(k, e) {
    e.extendAliases({
        Regex: {
            mask: "r",
            greedy: !1,
            repeat: "*",
            regex: null,
            regexTokens: null,
            tokenizer: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
            quantifierFilter: /[0-9]+[^,]/,
            isComplete: function(e, t) {
                return new RegExp(t.regex).test(e.join(""))
            },
            definitions: {
                r: {
                    validator: function(e, t, i, a, u) {
                        function c(e, t) {
                            this.matches = [], this.isGroup = e || !1, this.isQuantifier = t || !1, this.quantifier = {
                                min: 1,
                                max: 1
                            }, this.repeaterPart = void 0
                        }

                        function v(e, t) {
                            var i = !1;
                            t && (g += "(", y++);
                            for (var a = 0; a < e.matches.length; a++) {
                                var n = e.matches[a];
                                if (!0 === n.isGroup) i = v(n, !0);
                                else if (!0 === n.isQuantifier) {
                                    var r = k.inArray(n, e.matches),
                                        o = e.matches[r - 1],
                                        s = g;
                                    if (isNaN(n.quantifier.max)) {
                                        for (; n.repeaterPart && n.repeaterPart !== g && n.repeaterPart.length > g.length && !(i = v(o, !0)););
                                        (i = i || v(o, !0)) && (n.repeaterPart = g), g = s + n.quantifier.max
                                    } else {
                                        for (var l = 0, u = n.quantifier.max - 1; l < u && !(i = v(o, !0)); l++);
                                        g = s + "{" + n.quantifier.min + "," + n.quantifier.max + "}"
                                    }
                                } else if (void 0 !== n.matches)
                                    for (var c = 0; c < n.length && !(i = v(n[c], t)); c++);
                                else {
                                    var f;
                                    if ("[" == n.charAt(0)) {
                                        f = g, f += n;
                                        for (var d = 0; d < y; d++) f += ")";
                                        i = new RegExp("^(" + f + ")$").test(h)
                                    } else
                                        for (var p = 0, m = n.length; p < m; p++)
                                            if ("\\" !== n.charAt(p)) {
                                                f = g, f = (f += n.substr(0, p + 1)).replace(/\|$/, "");
                                                for (d = 0; d < y; d++) f += ")";
                                                if (i = new RegExp("^(" + f + ")$").test(h)) break
                                            }
                                    g += n
                                }
                                if (i) break
                            }
                            return t && (g += ")", y--), i
                        }
                        var h, f, n = t.buffer.slice(),
                            g = "",
                            r = !1,
                            y = 0;
                        null === u.regexTokens && function() {
                            var e, t, i = new c,
                                a = [];
                            for (u.regexTokens = []; e = u.tokenizer.exec(u.regex);) switch (t = e[0], t.charAt(0)) {
                                case "(":
                                    a.push(new c(!0));
                                    break;
                                case ")":
                                    f = a.pop(), 0 < a.length ? a[a.length - 1].matches.push(f) : i.matches.push(f);
                                    break;
                                case "{":
                                case "+":
                                case "*":
                                    var n = new c(!1, !0),
                                        r = (t = t.replace(/[{}]/g, "")).split(","),
                                        o = isNaN(r[0]) ? r[0] : parseInt(r[0]),
                                        s = 1 === r.length ? o : isNaN(r[1]) ? r[1] : parseInt(r[1]);
                                    if (n.quantifier = {
                                            min: o,
                                            max: s
                                        }, 0 < a.length) {
                                        var l = a[a.length - 1].matches;
                                        (e = l.pop()).isGroup || ((f = new c(!0)).matches.push(e), e = f), l.push(e), l.push(n)
                                    } else(e = i.matches.pop()).isGroup || ((f = new c(!0)).matches.push(e), e = f), i.matches.push(e), i.matches.push(n);
                                    break;
                                default:
                                    0 < a.length ? a[a.length - 1].matches.push(t) : i.matches.push(t)
                            }
                            0 < i.matches.length && u.regexTokens.push(i)
                        }(), n.splice(i, 0, e), h = n.join("");
                        for (var o = 0; o < u.regexTokens.length; o++) {
                            var s = u.regexTokens[o];
                            if (r = v(s, s.isGroup)) break
                        }
                        return r
                    },
                    cardinality: 1
                }
            }
        }
    })
}(jQuery, Inputmask)